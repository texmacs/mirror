This is guile.info, produced by makeinfo version 4.13 from guile.texi.

This reference manual documents Guile, GNU's Ubiquitous Intelligent
Language for Extensions.  This is edition 1.1 corresponding to Guile
1.8.8.

   Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
2007, 2008, 2009, 2010 Free Software Foundation.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
no Invariant Sections, with the Front-Cover Texts being "A GNU Manual,"
and with the Back-Cover Text "You are free to copy and modify this GNU
Manual.".  A copy of the license is included in the section entitled
"GNU Free Documentation License".

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Guile Reference: (guile).     The Guile reference manual.
END-INFO-DIR-ENTRY


File: guile.info,  Node: Arithmetic,  Next: Scientific,  Prev: Complex,  Up: Numbers

5.5.2.11 Arithmetic Functions
.............................

The C arithmetic functions below always takes two arguments, while the
Scheme functions can take an arbitrary number.  When you need to invoke
them with just one argument, for example to compute the equivalent od
`(- x)', pass `SCM_UNDEFINED' as the second one: `scm_difference (x,
SCM_UNDEFINED)'.

 -- Scheme Procedure: + z1 ...
 -- C Function: scm_sum (z1, z2)
     Return the sum of all parameter values.  Return 0 if called
     without any parameters.

 -- Scheme Procedure: - z1 z2 ...
 -- C Function: scm_difference (z1, z2)
     If called with one argument Z1, -Z1 is returned. Otherwise the sum
     of all but the first argument are subtracted from the first
     argument.

 -- Scheme Procedure: * z1 ...
 -- C Function: scm_product (z1, z2)
     Return the product of all arguments.  If called without arguments,
     1 is returned.

 -- Scheme Procedure: / z1 z2 ...
 -- C Function: scm_divide (z1, z2)
     Divide the first argument by the product of the remaining
     arguments.  If called with one argument Z1, 1/Z1 is returned.

 -- Scheme Procedure: 1+ z
 -- C Function: scm_oneplus (z)
     Return Z + 1.

 -- Scheme Procedure: 1- z
 -- C function: scm_oneminus (z)
     Return Z - 1.

 -- Scheme Procedure: abs x
 -- C Function: scm_abs (x)
     Return the absolute value of X.

     X must be a number with zero imaginary part.  To calculate the
     magnitude of a complex number, use `magnitude' instead.

 -- Scheme Procedure: max x1 x2 ...
 -- C Function: scm_max (x1, x2)
     Return the maximum of all parameter values.

 -- Scheme Procedure: min x1 x2 ...
 -- C Function: scm_min (x1, x2)
     Return the minimum of all parameter values.

 -- Scheme Procedure: truncate x
 -- C Function: scm_truncate_number (x)
     Round the inexact number X towards zero.

 -- Scheme Procedure: round x
 -- C Function: scm_round_number (x)
     Round the inexact number X to the nearest integer.  When exactly
     halfway between two integers, round to the even one.

 -- Scheme Procedure: floor x
 -- C Function: scm_floor (x)
     Round the number X towards minus infinity.

 -- Scheme Procedure: ceiling x
 -- C Function: scm_ceiling (x)
     Round the number X towards infinity.

 -- C Function: double scm_c_truncate (double x)
 -- C Function: double scm_c_round (double x)
     Like `scm_truncate_number' or `scm_round_number', respectively,
     but these functions take and return `double' values.


File: guile.info,  Node: Scientific,  Next: Primitive Numerics,  Prev: Arithmetic,  Up: Numbers

5.5.2.12 Scientific Functions
.............................

The following procedures accept any kind of number as arguments,
including complex numbers.

 -- Scheme Procedure: sqrt z
     Return the square root of Z.  Of the two possible roots (positive
     and negative), the one with the a positive real part is returned,
     or if that's zero then a positive imaginary part.  Thus,

          (sqrt 9.0)       => 3.0
          (sqrt -9.0)      => 0.0+3.0i
          (sqrt 1.0+1.0i)  => 1.09868411346781+0.455089860562227i
          (sqrt -1.0-1.0i) => 0.455089860562227-1.09868411346781i

 -- Scheme Procedure: expt z1 z2
     Return Z1 raised to the power of Z2.

 -- Scheme Procedure: sin z
     Return the sine of Z.

 -- Scheme Procedure: cos z
     Return the cosine of Z.

 -- Scheme Procedure: tan z
     Return the tangent of Z.

 -- Scheme Procedure: asin z
     Return the arcsine of Z.

 -- Scheme Procedure: acos z
     Return the arccosine of Z.

 -- Scheme Procedure: atan z
 -- Scheme Procedure: atan y x
     Return the arctangent of Z, or of Y/X.

 -- Scheme Procedure: exp z
     Return e to the power of Z, where e is the base of natural
     logarithms (2.71828...).

 -- Scheme Procedure: log z
     Return the natural logarithm of Z.

 -- Scheme Procedure: log10 z
     Return the base 10 logarithm of Z.

 -- Scheme Procedure: sinh z
     Return the hyperbolic sine of Z.

 -- Scheme Procedure: cosh z
     Return the hyperbolic cosine of Z.

 -- Scheme Procedure: tanh z
     Return the hyperbolic tangent of Z.

 -- Scheme Procedure: asinh z
     Return the hyperbolic arcsine of Z.

 -- Scheme Procedure: acosh z
     Return the hyperbolic arccosine of Z.

 -- Scheme Procedure: atanh z
     Return the hyperbolic arctangent of Z.


File: guile.info,  Node: Primitive Numerics,  Next: Bitwise Operations,  Prev: Scientific,  Up: Numbers

5.5.2.13 Primitive Numeric Functions
....................................

Many of Guile's numeric procedures which accept any kind of numbers as
arguments, including complex numbers, are implemented as Scheme
procedures that use the following real number-based primitives.  These
primitives signal an error if they are called with complex arguments.

 -- Scheme Procedure: $abs x
     Return the absolute value of X.

 -- Scheme Procedure: $sqrt x
     Return the square root of X.

 -- Scheme Procedure: $expt x y
 -- C Function: scm_sys_expt (x, y)
     Return X raised to the power of Y. This procedure does not accept
     complex arguments.

 -- Scheme Procedure: $sin x
     Return the sine of X.

 -- Scheme Procedure: $cos x
     Return the cosine of X.

 -- Scheme Procedure: $tan x
     Return the tangent of X.

 -- Scheme Procedure: $asin x
     Return the arcsine of X.

 -- Scheme Procedure: $acos x
     Return the arccosine of X.

 -- Scheme Procedure: $atan x
     Return the arctangent of X in the range -PI/2 to PI/2.

 -- Scheme Procedure: $atan2 x y
 -- C Function: scm_sys_atan2 (x, y)
     Return the arc tangent of the two arguments X and Y. This is
     similar to calculating the arc tangent of X / Y, except that the
     signs of both arguments are used to determine the quadrant of the
     result. This procedure does not accept complex arguments.

 -- Scheme Procedure: $exp x
     Return e to the power of X, where e is the base of natural
     logarithms (2.71828...).

 -- Scheme Procedure: $log x
     Return the natural logarithm of X.

 -- Scheme Procedure: $sinh x
     Return the hyperbolic sine of X.

 -- Scheme Procedure: $cosh x
     Return the hyperbolic cosine of X.

 -- Scheme Procedure: $tanh x
     Return the hyperbolic tangent of X.

 -- Scheme Procedure: $asinh x
     Return the hyperbolic arcsine of X.

 -- Scheme Procedure: $acosh x
     Return the hyperbolic arccosine of X.

 -- Scheme Procedure: $atanh x
     Return the hyperbolic arctangent of X.

   C functions for the above are provided by the standard mathematics
library.  Naturally these expect and return `double' arguments (*note
Mathematics: (libc)Mathematics.).

     Scheme Procedure   C Function
     `$abs'             `fabs'
     `$sqrt'            `sqrt'
     `$sin'             `sin'
     `$cos'             `cos'
     `$tan'             `tan'
     `$asin'            `asin'
     `$acos'            `acos'
     `$atan'            `atan'
     `$atan2'           `atan2'
     `$exp'             `exp'
     `$expt'            `pow'
     `$log'             `log'
     `$sinh'            `sinh'
     `$cosh'            `cosh'
     `$tanh'            `tanh'
     `$asinh'           `asinh'
     `$acosh'           `acosh'
     `$atanh'           `atanh'

   `asinh', `acosh' and `atanh' are C99 standard but might not be
available on older systems.  Guile provides the following equivalents
(on all systems).

 -- C Function: double scm_asinh (double x)
 -- C Function: double scm_acosh (double x)
 -- C Function: double scm_atanh (double x)
     Return the hyperbolic arcsine, arccosine or arctangent of X
     respectively.


File: guile.info,  Node: Bitwise Operations,  Next: Random,  Prev: Primitive Numerics,  Up: Numbers

5.5.2.14 Bitwise Operations
...........................

For the following bitwise functions, negative numbers are treated as
infinite precision twos-complements.  For instance -6 is bits
...111010, with infinitely many ones on the left.  It can be seen that
adding 6 (binary 110) to such a bit pattern gives all zeros.

 -- Scheme Procedure: logand n1 n2 ...
 -- C Function: scm_logand (n1, n2)
     Return the bitwise AND of the integer arguments.

          (logand) => -1
          (logand 7) => 7
          (logand #b111 #b011 #b001) => 1

 -- Scheme Procedure: logior n1 n2 ...
 -- C Function: scm_logior (n1, n2)
     Return the bitwise OR of the integer arguments.

          (logior) => 0
          (logior 7) => 7
          (logior #b000 #b001 #b011) => 3

 -- Scheme Procedure: logxor n1 n2 ...
 -- C Function: scm_loxor (n1, n2)
     Return the bitwise XOR of the integer arguments.  A bit is set in
     the result if it is set in an odd number of arguments.

          (logxor) => 0
          (logxor 7) => 7
          (logxor #b000 #b001 #b011) => 2
          (logxor #b000 #b001 #b011 #b011) => 1

 -- Scheme Procedure: lognot n
 -- C Function: scm_lognot (n)
     Return the integer which is the ones-complement of the integer
     argument, ie. each 0 bit is changed to 1 and each 1 bit to 0.

          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

 -- Scheme Procedure: logtest j k
 -- C Function: scm_logtest (j, k)
     Test whether J and K have any 1 bits in common.  This is
     equivalent to `(not (zero? (logand j k)))', but without actually
     calculating the `logand', just testing for non-zero.

          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

 -- Scheme Procedure: logbit? index j
 -- C Function: scm_logbit_p (index, j)
     Test whether bit number INDEX in J is set.  INDEX starts from 0
     for the least significant bit.

          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

 -- Scheme Procedure: ash n cnt
 -- C Function: scm_ash (n, cnt)
     Return N shifted left by CNT bits, or shifted right if CNT is
     negative.  This is an "arithmetic" shift.

     This is effectively a multiplication by 2^CNT, and when CNT is
     negative it's a division, rounded towards negative infinity.
     (Note that this is not the same rounding as `quotient' does.)

     With N viewed as an infinite precision twos complement, `ash'
     means a left shift introducing zero bits, or a right shift
     dropping bits.

          (number->string (ash #b1 3) 2)     => "1000"
          (number->string (ash #b1010 -1) 2) => "101"

          ;; -23 is bits ...11101001, -6 is bits ...111010
          (ash -23 -2) => -6

 -- Scheme Procedure: logcount n
 -- C Function: scm_logcount (n)
     Return the number of bits in integer N.  If N is positive, the
     1-bits in its binary representation are counted.  If negative, the
     0-bits in its two's-complement binary representation are counted.
     If zero, 0 is returned.

          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

 -- Scheme Procedure: integer-length n
 -- C Function: scm_integer_length (n)
     Return the number of bits necessary to represent N.

     For positive N this is how many bits to the most significant one
     bit.  For negative N it's how many bits to the most significant
     zero bit in twos complement form.

          (integer-length #b10101010) => 8
          (integer-length #b1111)     => 4
          (integer-length 0)          => 0
          (integer-length -1)         => 0
          (integer-length -256)       => 8
          (integer-length -257)       => 9

 -- Scheme Procedure: integer-expt n k
 -- C Function: scm_integer_expt (n, k)
     Return N raised to the power K.  K must be an exact integer, N can
     be any number.

     Negative K is supported, and results in 1/n^abs(k) in the usual
     way.  N^0 is 1, as usual, and that includes 0^0 is 1.

          (integer-expt 2 5)   => 32
          (integer-expt -3 3)  => -27
          (integer-expt 5 -3)  => 1/125
          (integer-expt 0 0)   => 1

 -- Scheme Procedure: bit-extract n start end
 -- C Function: scm_bit_extract (n, start, end)
     Return the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

          (number->string (bit-extract #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-extract #b1101101010 4 9) 2)
             => "10110"


File: guile.info,  Node: Random,  Prev: Bitwise Operations,  Up: Numbers

5.5.2.15 Random Number Generation
.................................

Pseudo-random numbers are generated from a random state object, which
can be created with `seed->random-state'.  The STATE parameter to the
various functions below is optional, it defaults to the state object in
the `*random-state*' variable.

 -- Scheme Procedure: copy-random-state [state]
 -- C Function: scm_copy_random_state (state)
     Return a copy of the random state STATE.

 -- Scheme Procedure: random n [state]
 -- C Function: scm_random (n, state)
     Return a number in [0, N).

     Accepts a positive integer or real n and returns a number of the
     same type between zero (inclusive) and N (exclusive). The values
     returned have a uniform distribution.

 -- Scheme Procedure: random:exp [state]
 -- C Function: scm_random_exp (state)
     Return an inexact real in an exponential distribution with mean 1.
     For an exponential distribution with mean U use `(* U
     (random:exp))'.

 -- Scheme Procedure: random:hollow-sphere! vect [state]
 -- C Function: scm_random_hollow_sphere_x (vect, state)
     Fills VECT with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of VECT as coordinates in space
     of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed over the surface of the unit n-sphere.

 -- Scheme Procedure: random:normal [state]
 -- C Function: scm_random_normal (state)
     Return an inexact real in a normal distribution.  The distribution
     used has mean 0 and standard deviation 1.  For a normal
     distribution with mean M and standard deviation D use `(+ M (* D
     (random:normal)))'.

 -- Scheme Procedure: random:normal-vector! vect [state]
 -- C Function: scm_random_normal_vector_x (vect, state)
     Fills VECT with inexact real random numbers that are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

 -- Scheme Procedure: random:solid-sphere! vect [state]
 -- C Function: scm_random_solid_sphere_x (vect, state)
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in
     space of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed within the unit N-sphere.

 -- Scheme Procedure: random:uniform [state]
 -- C Function: scm_random_uniform (state)
     Return a uniformly distributed inexact real random number in [0,1).

 -- Scheme Procedure: seed->random-state seed
 -- C Function: scm_seed_to_random_state (seed)
     Return a new random state using SEED.

 -- Variable: *random-state*
     The global random state used by the above functions when the STATE
     parameter is not given.

   Note that the initial value of `*random-state*' is the same every
time Guile starts up.  Therefore, if you don't pass a STATE parameter
to the above procedures, and you don't set `*random-state*' to
`(seed->random-state your-seed)', where `your-seed' is something that
_isn't_ the same every time, you'll get the same sequence of "random"
numbers on every run.

   For example, unless the relevant source code has changed, `(map
random (cdr (iota 30)))', if the first use of random numbers since
Guile started up, will always give:

     (map random (cdr (iota 19)))
     =>
     (0 1 1 2 2 2 1 2 6 7 10 0 5 3 12 5 5 12)

   To use the time of day as the random seed, you can use code like
this:

     (let ((time (gettimeofday)))
       (set! *random-state*
             (seed->random-state (+ (car time)
                                    (cdr time)))))

And then (depending on the time of day, of course):

     (map random (cdr (iota 19)))
     =>
     (0 0 1 0 2 4 5 4 5 5 9 3 10 1 8 3 14 17)

   For security applications, such as password generation, you should
use more bits of seed.  Otherwise an open source password generator
could be attacked by guessing the seed... but that's a subject for
another manual.


File: guile.info,  Node: Characters,  Next: Character Sets,  Prev: Numbers,  Up: Simple Data Types

5.5.3 Characters
----------------

In Scheme, a character literal is written as `#\NAME' where NAME is the
name of the character that you want.  Printable characters have their
usual single character name; for example, `#\a' is a lower case `a'.

   Most of the "control characters" (those below codepoint 32) in the
ASCII character set, as well as the space, may be referred to by longer
names: for example, `#\tab', `#\esc', `#\stx', and so on.  The
following table describes the ASCII names for each character.

0 = `#\nul'        1 = `#\soh'        2 = `#\stx'        3 = `#\etx'
4 = `#\eot'        5 = `#\enq'        6 = `#\ack'        7 = `#\bel'
8 = `#\bs'         9 = `#\ht'         10 = `#\nl'        11 = `#\vt'
12 = `#\np'        13 = `#\cr'        14 = `#\so'        15 = `#\si'
16 = `#\dle'       17 = `#\dc1'       18 = `#\dc2'       19 = `#\dc3'
20 = `#\dc4'       21 = `#\nak'       22 = `#\syn'       23 = `#\etb'
24 = `#\can'       25 = `#\em'        26 = `#\sub'       27 = `#\esc'
28 = `#\fs'        29 = `#\gs'        30 = `#\rs'        31 = `#\us'
32 = `#\sp'                                              

   The "delete" character (octal 177) may be referred to with the name
`#\del'.

   Several characters have more than one name:

Alias           Original
`#\space'       `#\sp'
`#\newline'     `#\nl'
`#\tab'         `#\ht'
`#\backspace'   `#\bs'
`#\return'      `#\cr'
`#\page'        `#\np'
`#\null'        `#\nul'

 -- Scheme Procedure: char? x
 -- C Function: scm_char_p (x)
     Return `#t' iff X is a character, else `#f'.

 -- Scheme Procedure: char=? x y
     Return `#t' iff X is the same character as Y, else `#f'.

 -- Scheme Procedure: char<? x y
     Return `#t' iff X is less than Y in the ASCII sequence, else `#f'.

 -- Scheme Procedure: char<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII
     sequence, else `#f'.

 -- Scheme Procedure: char>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence, else
     `#f'.

 -- Scheme Procedure: char>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence, else `#f'.

 -- Scheme Procedure: char-ci=? x y
     Return `#t' iff X is the same character as Y ignoring case, else
     `#f'.

 -- Scheme Procedure: char-ci<? x y
     Return `#t' iff X is less than Y in the ASCII sequence ignoring
     case, else `#f'.

 -- Scheme Procedure: char-ci<=? x y
     Return `#t' iff X is less than or equal to Y in the ASCII sequence
     ignoring case, else `#f'.

 -- Scheme Procedure: char-ci>? x y
     Return `#t' iff X is greater than Y in the ASCII sequence ignoring
     case, else `#f'.

 -- Scheme Procedure: char-ci>=? x y
     Return `#t' iff X is greater than or equal to Y in the ASCII
     sequence ignoring case, else `#f'.

 -- Scheme Procedure: char-alphabetic? chr
 -- C Function: scm_char_alphabetic_p (chr)
     Return `#t' iff CHR is alphabetic, else `#f'.

 -- Scheme Procedure: char-numeric? chr
 -- C Function: scm_char_numeric_p (chr)
     Return `#t' iff CHR is numeric, else `#f'.

 -- Scheme Procedure: char-whitespace? chr
 -- C Function: scm_char_whitespace_p (chr)
     Return `#t' iff CHR is whitespace, else `#f'.

 -- Scheme Procedure: char-upper-case? chr
 -- C Function: scm_char_upper_case_p (chr)
     Return `#t' iff CHR is uppercase, else `#f'.

 -- Scheme Procedure: char-lower-case? chr
 -- C Function: scm_char_lower_case_p (chr)
     Return `#t' iff CHR is lowercase, else `#f'.

 -- Scheme Procedure: char-is-both? chr
 -- C Function: scm_char_is_both_p (chr)
     Return `#t' iff CHR is either uppercase or lowercase, else `#f'.

 -- Scheme Procedure: char->integer chr
 -- C Function: scm_char_to_integer (chr)
     Return the number corresponding to ordinal position of CHR in the
     ASCII sequence.

 -- Scheme Procedure: integer->char n
 -- C Function: scm_integer_to_char (n)
     Return the character at position N in the ASCII sequence.

 -- Scheme Procedure: char-upcase chr
 -- C Function: scm_char_upcase (chr)
     Return the uppercase character version of CHR.

 -- Scheme Procedure: char-downcase chr
 -- C Function: scm_char_downcase (chr)
     Return the lowercase character version of CHR.


File: guile.info,  Node: Character Sets,  Next: Strings,  Prev: Characters,  Up: Simple Data Types

5.5.4 Character Sets
--------------------

The features described in this section correspond directly to SRFI-14.

   The data type "charset" implements sets of characters (*note
Characters::).  Because the internal representation of character sets
is not visible to the user, a lot of procedures for handling them are
provided.

   Character sets can be created, extended, tested for the membership
of a characters and be compared to other character sets.

   The Guile implementation of character sets currently deals only with
8-bit characters.  In the future, when Guile gets support for
international character sets, this will change, but the functions
provided here will always then be able to efficiently cope with very
large character sets.

* Menu:

* Character Set Predicates/Comparison::
* Iterating Over Character Sets::  Enumerate charset elements.
* Creating Character Sets::        Making new charsets.
* Querying Character Sets::        Test charsets for membership etc.
* Character-Set Algebra::          Calculating new charsets.
* Standard Character Sets::        Variables containing predefined charsets.


File: guile.info,  Node: Character Set Predicates/Comparison,  Next: Iterating Over Character Sets,  Up: Character Sets

5.5.4.1 Character Set Predicates/Comparison
...........................................

Use these procedures for testing whether an object is a character set,
or whether several character sets are equal or subsets of each other.
`char-set-hash' can be used for calculating a hash value, maybe for
usage in fast lookup procedures.

 -- Scheme Procedure: char-set? obj
 -- C Function: scm_char_set_p (obj)
     Return `#t' if OBJ is a character set, `#f' otherwise.

 -- Scheme Procedure: char-set= . char_sets
 -- C Function: scm_char_set_eq (char_sets)
     Return `#t' if all given character sets are equal.

 -- Scheme Procedure: char-set<= . char_sets
 -- C Function: scm_char_set_leq (char_sets)
     Return `#t' if every character set CSi is a subset of character
     set CSi+1.

 -- Scheme Procedure: char-set-hash cs [bound]
 -- C Function: scm_char_set_hash (cs, bound)
     Compute a hash value for the character set CS.  If BOUND is given
     and non-zero, it restricts the returned value to the range 0 ...
     BOUND - 1.


File: guile.info,  Node: Iterating Over Character Sets,  Next: Creating Character Sets,  Prev: Character Set Predicates/Comparison,  Up: Character Sets

5.5.4.2 Iterating Over Character Sets
.....................................

Character set cursors are a means for iterating over the members of a
character sets.  After creating a character set cursor with
`char-set-cursor', a cursor can be dereferenced with `char-set-ref',
advanced to the next member with `char-set-cursor-next'.  Whether a
cursor has passed past the last element of the set can be checked with
`end-of-char-set?'.

   Additionally, mapping and (un-)folding procedures for character sets
are provided.

 -- Scheme Procedure: char-set-cursor cs
 -- C Function: scm_char_set_cursor (cs)
     Return a cursor into the character set CS.

 -- Scheme Procedure: char-set-ref cs cursor
 -- C Function: scm_char_set_ref (cs, cursor)
     Return the character at the current cursor position CURSOR in the
     character set CS.  It is an error to pass a cursor for which
     `end-of-char-set?' returns true.

 -- Scheme Procedure: char-set-cursor-next cs cursor
 -- C Function: scm_char_set_cursor_next (cs, cursor)
     Advance the character set cursor CURSOR to the next character in
     the character set CS.  It is an error if the cursor given
     satisfies `end-of-char-set?'.

 -- Scheme Procedure: end-of-char-set? cursor
 -- C Function: scm_end_of_char_set_p (cursor)
     Return `#t' if CURSOR has reached the end of a character set, `#f'
     otherwise.

 -- Scheme Procedure: char-set-fold kons knil cs
 -- C Function: scm_char_set_fold (kons, knil, cs)
     Fold the procedure KONS over the character set CS, initializing it
     with KNIL.

 -- Scheme Procedure: char-set-unfold p f g seed [base_cs]
 -- C Function: scm_char_set_unfold (p, f, g, seed, base_cs)
     This is a fundamental constructor for character sets.
        * G is used to generate a series of "seed" values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character. These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

 -- Scheme Procedure: char-set-unfold! p f g seed base_cs
 -- C Function: scm_char_set_unfold_x (p, f, g, seed, base_cs)
     This is a fundamental constructor for character sets.
        * G is used to generate a series of "seed" values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character. These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

 -- Scheme Procedure: char-set-for-each proc cs
 -- C Function: scm_char_set_for_each (proc, cs)
     Apply PROC to every character in the character set CS.  The return
     value is not specified.

 -- Scheme Procedure: char-set-map proc cs
 -- C Function: scm_char_set_map (proc, cs)
     Map the procedure PROC over every character in CS.  PROC must be a
     character -> character procedure.


File: guile.info,  Node: Creating Character Sets,  Next: Querying Character Sets,  Prev: Iterating Over Character Sets,  Up: Character Sets

5.5.4.3 Creating Character Sets
...............................

New character sets are produced with these procedures.

 -- Scheme Procedure: char-set-copy cs
 -- C Function: scm_char_set_copy (cs)
     Return a newly allocated character set containing all characters
     in CS.

 -- Scheme Procedure: char-set . rest
 -- C Function: scm_char_set (rest)
     Return a character set containing all given characters.

 -- Scheme Procedure: list->char-set list [base_cs]
 -- C Function: scm_list_to_char_set (list, base_cs)
     Convert the character list LIST to a character set.  If the
     character set BASE_CS is given, the character in this set are also
     included in the result.

 -- Scheme Procedure: list->char-set! list base_cs
 -- C Function: scm_list_to_char_set_x (list, base_cs)
     Convert the character list LIST to a character set.  The
     characters are added to BASE_CS and BASE_CS is returned.

 -- Scheme Procedure: string->char-set str [base_cs]
 -- C Function: scm_string_to_char_set (str, base_cs)
     Convert the string STR to a character set.  If the character set
     BASE_CS is given, the characters in this set are also included in
     the result.

 -- Scheme Procedure: string->char-set! str base_cs
 -- C Function: scm_string_to_char_set_x (str, base_cs)
     Convert the string STR to a character set.  The characters from
     the string are added to BASE_CS, and BASE_CS is returned.

 -- Scheme Procedure: char-set-filter pred cs [base_cs]
 -- C Function: scm_char_set_filter (pred, cs, base_cs)
     Return a character set containing every character from CS so that
     it satisfies PRED.  If provided, the characters from BASE_CS are
     added to the result.

 -- Scheme Procedure: char-set-filter! pred cs base_cs
 -- C Function: scm_char_set_filter_x (pred, cs, base_cs)
     Return a character set containing every character from CS so that
     it satisfies PRED.  The characters are added to BASE_CS and
     BASE_CS is returned.

 -- Scheme Procedure: ucs-range->char-set lower upper [error [base_cs]]
 -- C Function: scm_ucs_range_to_char_set (lower, upper, error, base_cs)
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signalled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resultung character set.

     The characters in BASE_CS are added to the result, if given.

 -- Scheme Procedure: ucs-range->char-set! lower upper error base_cs
 -- C Function: scm_ucs_range_to_char_set_x (lower, upper, error,
          base_cs)
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signalled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resultung character set.

     The characters are added to BASE_CS and BASE_CS is returned.

 -- Scheme Procedure: ->char-set x
 -- C Function: scm_to_char_set (x)
     Coerces x into a char-set. X may be a string, character or
     char-set. A string is converted to the set of its constituent
     characters; a character is converted to a singleton set; a
     char-set is returned as-is.


File: guile.info,  Node: Querying Character Sets,  Next: Character-Set Algebra,  Prev: Creating Character Sets,  Up: Character Sets

5.5.4.4 Querying Character Sets
...............................

Access the elements and other information of a character set with these
procedures.

 -- Scheme Procedure: char-set-size cs
 -- C Function: scm_char_set_size (cs)
     Return the number of elements in character set CS.

 -- Scheme Procedure: char-set-count pred cs
 -- C Function: scm_char_set_count (pred, cs)
     Return the number of the elements int the character set CS which
     satisfy the predicate PRED.

 -- Scheme Procedure: char-set->list cs
 -- C Function: scm_char_set_to_list (cs)
     Return a list containing the elements of the character set CS.

 -- Scheme Procedure: char-set->string cs
 -- C Function: scm_char_set_to_string (cs)
     Return a string containing the elements of the character set CS.
     The order in which the characters are placed in the string is not
     defined.

 -- Scheme Procedure: char-set-contains? cs ch
 -- C Function: scm_char_set_contains_p (cs, ch)
     Return `#t' iff the character CH is contained in the character set
     CS.

 -- Scheme Procedure: char-set-every pred cs
 -- C Function: scm_char_set_every (pred, cs)
     Return a true value if every character in the character set CS
     satisfies the predicate PRED.

 -- Scheme Procedure: char-set-any pred cs
 -- C Function: scm_char_set_any (pred, cs)
     Return a true value if any character in the character set CS
     satisfies the predicate PRED.


File: guile.info,  Node: Character-Set Algebra,  Next: Standard Character Sets,  Prev: Querying Character Sets,  Up: Character Sets

5.5.4.5 Character-Set Algebra
.............................

Character sets can be manipulated with the common set algebra operation,
such as union, complement, intersection etc.  All of these procedures
provide side-effecting variants, which modify their character set
argument(s).

 -- Scheme Procedure: char-set-adjoin cs . rest
 -- C Function: scm_char_set_adjoin (cs, rest)
     Add all character arguments to the first argument, which must be a
     character set.

 -- Scheme Procedure: char-set-delete cs . rest
 -- C Function: scm_char_set_delete (cs, rest)
     Delete all character arguments from the first argument, which must
     be a character set.

 -- Scheme Procedure: char-set-adjoin! cs . rest
 -- C Function: scm_char_set_adjoin_x (cs, rest)
     Add all character arguments to the first argument, which must be a
     character set.

 -- Scheme Procedure: char-set-delete! cs . rest
 -- C Function: scm_char_set_delete_x (cs, rest)
     Delete all character arguments from the first argument, which must
     be a character set.

 -- Scheme Procedure: char-set-complement cs
 -- C Function: scm_char_set_complement (cs)
     Return the complement of the character set CS.

 -- Scheme Procedure: char-set-union . rest
 -- C Function: scm_char_set_union (rest)
     Return the union of all argument character sets.

 -- Scheme Procedure: char-set-intersection . rest
 -- C Function: scm_char_set_intersection (rest)
     Return the intersection of all argument character sets.

 -- Scheme Procedure: char-set-difference cs1 . rest
 -- C Function: scm_char_set_difference (cs1, rest)
     Return the difference of all argument character sets.

 -- Scheme Procedure: char-set-xor . rest
 -- C Function: scm_char_set_xor (rest)
     Return the exclusive-or of all argument character sets.

 -- Scheme Procedure: char-set-diff+intersection cs1 . rest
 -- C Function: scm_char_set_diff_plus_intersection (cs1, rest)
     Return the difference and the intersection of all argument
     character sets.

 -- Scheme Procedure: char-set-complement! cs
 -- C Function: scm_char_set_complement_x (cs)
     Return the complement of the character set CS.

 -- Scheme Procedure: char-set-union! cs1 . rest
 -- C Function: scm_char_set_union_x (cs1, rest)
     Return the union of all argument character sets.

 -- Scheme Procedure: char-set-intersection! cs1 . rest
 -- C Function: scm_char_set_intersection_x (cs1, rest)
     Return the intersection of all argument character sets.

 -- Scheme Procedure: char-set-difference! cs1 . rest
 -- C Function: scm_char_set_difference_x (cs1, rest)
     Return the difference of all argument character sets.

 -- Scheme Procedure: char-set-xor! cs1 . rest
 -- C Function: scm_char_set_xor_x (cs1, rest)
     Return the exclusive-or of all argument character sets.

 -- Scheme Procedure: char-set-diff+intersection! cs1 cs2 . rest
 -- C Function: scm_char_set_diff_plus_intersection_x (cs1, cs2, rest)
     Return the difference and the intersection of all argument
     character sets.


File: guile.info,  Node: Standard Character Sets,  Prev: Character-Set Algebra,  Up: Character Sets

5.5.4.6 Standard Character Sets
...............................

In order to make the use of the character set data type and procedures
useful, several predefined character set variables exist.

   Currently, the contents of these character sets are recomputed upon a
successful `setlocale' call (*note Locales::) in order to reflect the
characters available in the current locale's codeset.  For instance,
`char-set:letter' contains 52 characters under an ASCII locale (e.g.,
the default `C' locale) and 117 characters under an ISO-8859-1
("Latin-1") locale.

 -- Scheme Variable: char-set:lower-case
 -- C Variable: scm_char_set_lower_case
     All lower-case characters.

 -- Scheme Variable: char-set:upper-case
 -- C Variable: scm_char_set_upper_case
     All upper-case characters.

 -- Scheme Variable: char-set:title-case
 -- C Variable: scm_char_set_title_case
     This is empty, because ASCII has no titlecase characters.

 -- Scheme Variable: char-set:letter
 -- C Variable: scm_char_set_letter
     All letters, e.g. the union of `char-set:lower-case' and
     `char-set:upper-case'.

 -- Scheme Variable: char-set:digit
 -- C Variable: scm_char_set_digit
     All digits.

 -- Scheme Variable: char-set:letter+digit
 -- C Variable: scm_char_set_letter_and_digit
     The union of `char-set:letter' and `char-set:digit'.

 -- Scheme Variable: char-set:graphic
 -- C Variable: scm_char_set_graphic
     All characters which would put ink on the paper.

 -- Scheme Variable: char-set:printing
 -- C Variable: scm_char_set_printing
     The union of `char-set:graphic' and `char-set:whitespace'.

 -- Scheme Variable: char-set:whitespace
 -- C Variable: scm_char_set_whitespace
     All whitespace characters.

 -- Scheme Variable: char-set:blank
 -- C Variable: scm_char_set_blank
     All horizontal whitespace characters, that is `#\space' and
     `#\tab'.

 -- Scheme Variable: char-set:iso-control
 -- C Variable: scm_char_set_iso_control
     The ISO control characters with the codes 0-31 and 127.

 -- Scheme Variable: char-set:punctuation
 -- C Variable: scm_char_set_punctuation
     The characters `!"#%&'()*,-./:;?@[\\]_{}'

 -- Scheme Variable: char-set:symbol
 -- C Variable: scm_char_set_symbol
     The characters `$+<=>^`|~'.

 -- Scheme Variable: char-set:hex-digit
 -- C Variable: scm_char_set_hex_digit
     The hexadecimal digits `0123456789abcdefABCDEF'.

 -- Scheme Variable: char-set:ascii
 -- C Variable: scm_char_set_ascii
     All ASCII characters.

 -- Scheme Variable: char-set:empty
 -- C Variable: scm_char_set_empty
     The empty character set.

 -- Scheme Variable: char-set:full
 -- C Variable: scm_char_set_full
     This character set contains all possible characters.


File: guile.info,  Node: Strings,  Next: Regular Expressions,  Prev: Character Sets,  Up: Simple Data Types

5.5.5 Strings
-------------

Strings are fixed-length sequences of characters.  They can be created
by calling constructor procedures, but they can also literally get
entered at the REPL or in Scheme source files.

   Strings always carry the information about how many characters they
are composed of with them, so there is no special end-of-string
character, like in C.  That means that Scheme strings can contain any
character, even the `#\nul' character `\0'.

   To use strings efficiently, you need to know a bit about how Guile
implements them.  In Guile, a string consists of two parts, a head and
the actual memory where the characters are stored.  When a string (or a
substring of it) is copied, only a new head gets created, the memory is
usually not copied.  The two heads start out pointing to the same
memory.

   When one of these two strings is modified, as with `string-set!',
their common memory does get copied so that each string has its own
memory and modifying one does not accidently modify the other as well.
Thus, Guile's strings are `copy on write'; the actual copying of their
memory is delayed until one string is written to.

   This implementation makes functions like `substring' very efficient
in the common case that no modifications are done to the involved
strings.

   If you do know that your strings are getting modified right away, you
can use `substring/copy' instead of `substring'.  This function
performs the copy immediately at the time of creation.  This is more
efficient, especially in a multi-threaded program.  Also,
`substring/copy' can avoid the problem that a short substring holds on
to the memory of a very large original string that could otherwise be
recycled.

   If you want to avoid the copy altogether, so that modifications of
one string show up in the other, you can use `substring/shared'.  The
strings created by this procedure are called "mutation sharing
substrings" since the substring and the original string share
modifications to each other.

   If you want to prevent modifications, use `substring/read-only'.

   Guile provides all procedures of SRFI-13 and a few more.

* Menu:

* String Syntax::                   Read syntax for strings.
* String Predicates::               Testing strings for certain properties.
* String Constructors::             Creating new string objects.
* List/String Conversion::          Converting from/to lists of characters.
* String Selection::                Select portions from strings.
* String Modification::             Modify parts or whole strings.
* String Comparison::               Lexicographic ordering predicates.
* String Searching::                Searching in strings.
* Alphabetic Case Mapping::         Convert the alphabetic case of strings.
* Reversing and Appending Strings:: Appending strings to form a new string.
* Mapping Folding and Unfolding::   Iterating over strings.
* Miscellaneous String Operations:: Replicating, insertion, parsing, ...
* Conversion to/from C::


File: guile.info,  Node: String Syntax,  Next: String Predicates,  Up: Strings

5.5.5.1 String Read Syntax
..........................

The read syntax for strings is an arbitrarily long sequence of
characters enclosed in double quotes (").

   Backslash is an escape character and can be used to insert the
following special characters.  \" and \\ are R5RS standard, the rest
are Guile extensions, notice they follow C string syntax.

\\
     Backslash character.

\"
     Double quote character (an unescaped " is otherwise the end of the
     string).

\0
     NUL character (ASCII 0).

\a
     Bell character (ASCII 7).

\f
     Formfeed character (ASCII 12).

\n
     Newline character (ASCII 10).

\r
     Carriage return character (ASCII 13).

\t
     Tab character (ASCII 9).

\v
     Vertical tab character (ASCII 11).

\xHH
     Character code given by two hexadecimal digits.  For example \x7f
     for an ASCII DEL (127).

The following are examples of string literals:

     "foo"
     "bar plonk"
     "Hello World"
     "\"Hi\", he said."


File: guile.info,  Node: String Predicates,  Next: String Constructors,  Prev: String Syntax,  Up: Strings

5.5.5.2 String Predicates
.........................

The following procedures can be used to check whether a given string
fulfills some specified property.

 -- Scheme Procedure: string? obj
 -- C Function: scm_string_p (obj)
     Return `#t' if OBJ is a string, else `#f'.

 -- C Function: int scm_is_string (SCM obj)
     Returns `1' if OBJ is a string, `0' otherwise.

 -- Scheme Procedure: string-null? str
 -- C Function: scm_string_null_p (str)
     Return `#t' if STR's length is zero, and `#f' otherwise.
          (string-null? "")  => #t
          y                    => "foo"
          (string-null? y)     => #f

 -- Scheme Procedure: string-any char_pred s [start [end]]
 -- C Function: scm_string_any (char_pred, s, start, end)
     Check if CHAR_PRED is true for any character in string S.

     CHAR_PRED can be a character to check for any equal to that, or a
     character set (*note Character Sets::) to check for any in that
     set, or a predicate procedure to call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on
     the characters from START to END.  If CHAR_PRED returns true (ie.
     non-`#f'), `string-any' stops and that return value is the return
     from `string-any'.  The call on the last character (ie. at END-1),
     if that point is reached, is a tail call.

     If there are no characters in S (ie. START equals END) then the
     return is `#f'.

 -- Scheme Procedure: string-every char_pred s [start [end]]
 -- C Function: scm_string_every (char_pred, s, start, end)
     Check if CHAR_PRED is true for every character in string S.

     CHAR_PRED can be a character to check for every character equal to
     that, or a character set (*note Character Sets::) to check for
     every character being in that set, or a predicate procedure to
     call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on
     the characters from START to END.  If CHAR_PRED returns `#f',
     `string-every' stops and returns `#f'.  The call on the last
     character (ie. at END-1), if that point is reached, is a tail call
     and the return from that call is the return from `string-every'.

     If there are no characters in S (ie. START equals END) then the
     return is `#t'.


File: guile.info,  Node: String Constructors,  Next: List/String Conversion,  Prev: String Predicates,  Up: Strings

5.5.5.3 String Constructors
...........................

The string constructor procedures create new string objects, possibly
initializing them with some specified character data.  See also *Note
String Selection::, for ways to create strings from existing strings.

 -- Scheme Procedure: string char...
     Return a newly allocated string made from the given character
     arguments.

          (string #\x #\y #\z) => "xyz"
          (string)             => ""

 -- Scheme Procedure: list->string lst
 -- C Function: scm_string (lst)
     Return a newly allocated string made from a list of characters.

          (list->string '(#\a #\b #\c)) => "abc"

 -- Scheme Procedure: reverse-list->string lst
 -- C Function: scm_reverse_list_to_string (lst)
     Return a newly allocated string made from a list of characters, in
     reverse order.

          (reverse-list->string '(#\a #\B #\c)) => "cBa"

 -- Scheme Procedure: make-string k [chr]
 -- C Function: scm_make_string (k, chr)
     Return a newly allocated string of length K.  If CHR is given,
     then all elements of the string are initialized to CHR, otherwise
     the contents of the STRING are unspecified.

 -- C Function: SCM scm_c_make_string (size_t len, SCM chr)
     Like `scm_make_string', but expects the length as a `size_t'.

 -- Scheme Procedure: string-tabulate proc len
 -- C Function: scm_string_tabulate (proc, len)
     PROC is an integer->char procedure.  Construct a string of size
     LEN by applying PROC to each index to produce the corresponding
     string element.  The order in which PROC is applied to the indices
     is not specified.

 -- Scheme Procedure: string-join ls [delimiter [grammar]]
 -- C Function: scm_string_join (ls, delimiter, grammar)
     Append the string in the string list LS, using the string DELIM as
     a delimiter between the elements of LS.  GRAMMAR is a symbol which
     specifies how the delimiter is placed between the strings, and
     defaults to the symbol `infix'.

    `infix'
          Insert the separator between list elements.  An empty string
          will produce an empty list.

    `string-infix'
          Like `infix', but will raise an error if given the empty list.

    `suffix'
          Insert the separator after every list element.

    `prefix'
          Insert the separator before each list element.


File: guile.info,  Node: List/String Conversion,  Next: String Selection,  Prev: String Constructors,  Up: Strings

5.5.5.4 List/String conversion
..............................

When processing strings, it is often convenient to first convert them
into a list representation by using the procedure `string->list', work
with the resulting list, and then convert it back into a string.  These
procedures are useful for similar tasks.

 -- Scheme Procedure: string->list str [start [end]]
 -- C Function: scm_substring_to_list (str, start, end)
 -- C Function: scm_string_to_list (str)
     Convert the string STR into a list of characters.

 -- Scheme Procedure: string-split str chr
 -- C Function: scm_string_split (str, chr)
     Split the string STR into the a list of the substrings delimited
     by appearances of the character CHR.  Note that an empty substring
     between separator characters will result in an empty string in the
     result list.

          (string-split "root:x:0:0:root:/root:/bin/bash" #\:)
          =>
          ("root" "x" "0" "0" "root" "/root" "/bin/bash")

          (string-split "::" #\:)
          =>
          ("" "" "")

          (string-split "" #\:)
          =>
          ("")


File: guile.info,  Node: String Selection,  Next: String Modification,  Prev: List/String Conversion,  Up: Strings

5.5.5.5 String Selection
........................

Portions of strings can be extracted by these procedures.  `string-ref'
delivers individual characters whereas `substring' can be used to
extract substrings from longer strings.

 -- Scheme Procedure: string-length string
 -- C Function: scm_string_length (string)
     Return the number of characters in STRING.

 -- C Function: size_t scm_c_string_length (SCM str)
     Return the number of characters in STR as a `size_t'.

 -- Scheme Procedure: string-ref str k
 -- C Function: scm_string_ref (str, k)
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

 -- C Function: SCM scm_c_string_ref (SCM str, size_t k)
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

 -- Scheme Procedure: string-copy str [start [end]]
 -- C Function: scm_substring_copy (str, start, end)
 -- C Function: scm_string_copy (str)
     Return a copy of the given string STR.

     The returned string shares storage with STR initially, but it is
     copied as soon as one of the two strings is modified.

 -- Scheme Procedure: substring str start [end]
 -- C Function: scm_substring (str, start, end)
     Return a new string formed from the characters of STR beginning
     with index START (inclusive) and ending with index END (exclusive).
     STR must be a string, START and END must be exact integers
     satisfying:

     0 <= START <= END <= `(string-length STR)'.

     The returned string shares storage with STR initially, but it is
     copied as soon as one of the two strings is modified.

 -- Scheme Procedure: substring/shared str start [end]
 -- C Function: scm_substring_shared (str, start, end)
     Like `substring', but the strings continue to share their storage
     even if they are modified.  Thus, modifications to STR show up in
     the new string, and vice versa.

 -- Scheme Procedure: substring/copy str start [end]
 -- C Function: scm_substring_copy (str, start, end)
     Like `substring', but the storage for the new string is copied
     immediately.

 -- Scheme Procedure: substring/read-only str start [end]
 -- C Function: scm_substring_read_only (str, start, end)
     Like `substring', but the resulting string can not be modified.

 -- C Function: SCM scm_c_substring (SCM str, size_t start, size_t end)
 -- C Function: SCM scm_c_substring_shared (SCM str, size_t start,
          size_t end)
 -- C Function: SCM scm_c_substring_copy (SCM str, size_t start, size_t
          end)
 -- C Function: SCM scm_c_substring_read_only (SCM str, size_t start,
          size_t end)
     Like `scm_substring', etc. but the bounds are given as a `size_t'.

 -- Scheme Procedure: string-take s n
 -- C Function: scm_string_take (s, n)
     Return the N first characters of S.

 -- Scheme Procedure: string-drop s n
 -- C Function: scm_string_drop (s, n)
     Return all but the first N characters of S.

 -- Scheme Procedure: string-take-right s n
 -- C Function: scm_string_take_right (s, n)
     Return the N last characters of S.

 -- Scheme Procedure: string-drop-right s n
 -- C Function: scm_string_drop_right (s, n)
     Return all but the last N characters of S.

 -- Scheme Procedure: string-pad s len [chr [start [end]]]
 -- Scheme Procedure: string-pad-right s len [chr [start [end]]]
 -- C Function: scm_string_pad (s, len, chr, start, end)
 -- C Function: scm_string_pad_right (s, len, chr, start, end)
     Take characters START to END from the string S and either pad with
     CHAR or truncate them to give LEN characters.

     `string-pad' pads or truncates on the left, so for example

          (string-pad "x" 3)     => "  x"
          (string-pad "abcde" 3) => "cde"

     `string-pad-right' pads or truncates on the right, so for example

          (string-pad-right "x" 3)     => "x  "
          (string-pad-right "abcde" 3) => "abc"

 -- Scheme Procedure: string-trim s [char_pred [start [end]]]
 -- Scheme Procedure: string-trim-right s [char_pred [start [end]]]
 -- Scheme Procedure: string-trim-both s [char_pred [start [end]]]
 -- C Function: scm_string_trim (s, char_pred, start, end)
 -- C Function: scm_string_trim_right (s, char_pred, start, end)
 -- C Function: scm_string_trim_both (s, char_pred, start, end)
     Trim occurrances of CHAR_PRED from the ends of S.

     `string-trim' trims CHAR_PRED characters from the left (start) of
     the string, `string-trim-right' trims them from the right (end) of
     the string, `string-trim-both' trims from both ends.

     CHAR_PRED can be a character, a character set, or a predicate
     procedure to call on each character.  If CHAR_PRED is not given
     the default is whitespace as per `char-set:whitespace' (*note
     Standard Character Sets::).

          (string-trim " x ")              => "x "
          (string-trim-right "banana" #\a) => "banan"
          (string-trim-both ".,xy:;" char-set:punctuation)
                            => "xy"
          (string-trim-both "xyzzy" (lambda (c)
                                       (or (eqv? c #\x)
                                           (eqv? c #\y))))
                            => "zz"


File: guile.info,  Node: String Modification,  Next: String Comparison,  Prev: String Selection,  Up: Strings

5.5.5.6 String Modification
...........................

These procedures are for modifying strings in-place.  This means that
the result of the operation is not a new string; instead, the original
string's memory representation is modified.

 -- Scheme Procedure: string-set! str k chr
 -- C Function: scm_string_set_x (str, k, chr)
     Store CHR in element K of STR and return an unspecified value. K
     must be a valid index of STR.

 -- C Function: void scm_c_string_set_x (SCM str, size_t k, SCM chr)
     Like `scm_string_set_x', but the index is given as a `size_t'.

 -- Scheme Procedure: string-fill! str chr [start [end]]
 -- C Function: scm_substring_fill_x (str, chr, start, end)
 -- C Function: scm_string_fill_x (str, chr)
     Stores CHR in every element of the given STR and returns an
     unspecified value.

 -- Scheme Procedure: substring-fill! str start end fill
 -- C Function: scm_substring_fill_x (str, start, end, fill)
     Change every character in STR between START and END to FILL.

          (define y "abcdefg")
          (substring-fill! y 1 3 #\r)
          y
          => "arrdefg"

 -- Scheme Procedure: substring-move! str1 start1 end1 str2 start2
 -- C Function: scm_substring_move_x (str1, start1, end1, str2, start2)
     Copy the substring of STR1 bounded by START1 and END1 into STR2
     beginning at position START2.  STR1 and STR2 can be the same
     string.

 -- Scheme Procedure: string-copy! target tstart s [start [end]]
 -- C Function: scm_string_copy_x (target, tstart, s, start, end)
     Copy the sequence of characters from index range [START, END) in
     string S to string TARGET, beginning at index TSTART.  The
     characters are copied left-to-right or right-to-left as needed -
     the copy is guaranteed to work, even if TARGET and S are the same
     string.  It is an error if the copy operation runs off the end of
     the target string.


File: guile.info,  Node: String Comparison,  Next: String Searching,  Prev: String Modification,  Up: Strings

5.5.5.7 String Comparison
.........................

The procedures in this section are similar to the character ordering
predicates (*note Characters::), but are defined on character sequences.

   The first set is specified in R5RS and has names that end in `?'.
The second set is specified in SRFI-13 and the names have no ending
`?'.  The predicates ending in `-ci' ignore the character case when
comparing strings.

 -- Scheme Procedure: string=? s1 s2
     Lexicographic equality predicate; return `#t' if the two strings
     are the same length and contain the same characters in the same
     positions, otherwise return `#f'.

     The procedure `string-ci=?' treats upper and lower case letters as
     though they were the same character, but `string=?' treats upper
     and lower case as distinct characters.

 -- Scheme Procedure: string<? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than S2.

 -- Scheme Procedure: string<=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than or equal to S2.

 -- Scheme Procedure: string>? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than S2.

 -- Scheme Procedure: string>=? s1 s2
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than or equal to S2.

 -- Scheme Procedure: string-ci=? s1 s2
     Case-insensitive string equality predicate; return `#t' if the two
     strings are the same length and their component characters match
     (ignoring case) at each position; otherwise return `#f'.

 -- Scheme Procedure: string-ci<? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than S2 regardless of case.

 -- Scheme Procedure: string-ci<=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than or equal to S2 regardless of
     case.

 -- Scheme Procedure: string-ci>? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than S2 regardless of case.

 -- Scheme Procedure: string-ci>=? s1 s2
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than or equal to S2 regardless of
     case.

 -- Scheme Procedure: string-compare s1 s2 proc_lt proc_eq proc_gt
          [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_compare (s1, s2, proc_lt, proc_eq, proc_gt,
          start1, end1, start2, end2)
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] - that is, I is the first position that does not
     match.

 -- Scheme Procedure: string-compare-ci s1 s2 proc_lt proc_eq proc_gt
          [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_compare_ci (s1, s2, proc_lt, proc_eq,
          proc_gt, start1, end1, start2, end2)
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] - that is, I is the first position that does not
     match.  The character comparison is done case-insensitively.

 -- Scheme Procedure: string= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_eq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are not equal, a true value otherwise.

 -- Scheme Procedure: string<> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_neq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are equal, a true value otherwise.

 -- Scheme Procedure: string< s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_lt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.

 -- Scheme Procedure: string> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_gt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less or equal to S2, a true value otherwise.

 -- Scheme Procedure: string<= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_le (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater to S2, a true value otherwise.

 -- Scheme Procedure: string>= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ge (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less to S2, a true value otherwise.

 -- Scheme Procedure: string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_eq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are not equal, a true value otherwise.
     The character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_neq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are equal, a true value otherwise.  The
     character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_lt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.  The character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_gt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less or equal to S2, a true value otherwise.
     The character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_le (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_ge (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

 -- Scheme Procedure: string-hash s [bound [start [end]]]
 -- C Function: scm_substring_hash (s, bound, start, end)
     Compute a hash value for S.  the optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function. A positive value restricts the return value to the range
     [0,bound).

 -- Scheme Procedure: string-hash-ci s [bound [start [end]]]
 -- C Function: scm_substring_hash_ci (s, bound, start, end)
     Compute a hash value for S.  the optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function. A positive value restricts the return value to the range
     [0,bound).


File: guile.info,  Node: String Searching,  Next: Alphabetic Case Mapping,  Prev: String Comparison,  Up: Strings

5.5.5.8 String Searching
........................

 -- Scheme Procedure: string-index s char_pred [start [end]]
 -- C Function: scm_string_index (s, char_pred, start, end)
     Search through the string S from left to right, returning the
     index of the first occurence of a character which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure,

        * is in the set CHAR_PRED, if it is a character set.

 -- Scheme Procedure: string-rindex s char_pred [start [end]]
 -- C Function: scm_string_rindex (s, char_pred, start, end)
     Search through the string S from right to left, returning the
     index of the last occurence of a character which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

 -- Scheme Procedure: string-prefix-length s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_prefix_length (s1, s2, start1, end1, start2,
          end2)
     Return the length of the longest common prefix of the two strings.

 -- Scheme Procedure: string-prefix-length-ci s1 s2 [start1 [end1
          [start2 [end2]]]]
 -- C Function: scm_string_prefix_length_ci (s1, s2, start1, end1,
          start2, end2)
     Return the length of the longest common prefix of the two strings,
     ignoring character case.

 -- Scheme Procedure: string-suffix-length s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_suffix_length (s1, s2, start1, end1, start2,
          end2)
     Return the length of the longest common suffix of the two strings.

 -- Scheme Procedure: string-suffix-length-ci s1 s2 [start1 [end1
          [start2 [end2]]]]
 -- C Function: scm_string_suffix_length_ci (s1, s2, start1, end1,
          start2, end2)
     Return the length of the longest common suffix of the two strings,
     ignoring character case.

 -- Scheme Procedure: string-prefix? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_prefix_p (s1, s2, start1, end1, start2, end2)
     Is S1 a prefix of S2?

 -- Scheme Procedure: string-prefix-ci? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_prefix_ci_p (s1, s2, start1, end1, start2,
          end2)
     Is S1 a prefix of S2, ignoring character case?

 -- Scheme Procedure: string-suffix? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_suffix_p (s1, s2, start1, end1, start2, end2)
     Is S1 a suffix of S2?

 -- Scheme Procedure: string-suffix-ci? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_suffix_ci_p (s1, s2, start1, end1, start2,
          end2)
     Is S1 a suffix of S2, ignoring character case?

 -- Scheme Procedure: string-index-right s char_pred [start [end]]
 -- C Function: scm_string_index_right (s, char_pred, start, end)
     Search through the string S from right to left, returning the
     index of the last occurence of a character which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

 -- Scheme Procedure: string-skip s char_pred [start [end]]
 -- C Function: scm_string_skip (s, char_pred, start, end)
     Search through the string S from left to right, returning the
     index of the first occurence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisify the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

 -- Scheme Procedure: string-skip-right s char_pred [start [end]]
 -- C Function: scm_string_skip_right (s, char_pred, start, end)
     Search through the string S from right to left, returning the
     index of the last occurence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisfy the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

 -- Scheme Procedure: string-count s char_pred [start [end]]
 -- C Function: scm_string_count (s, char_pred, start, end)
     Return the count of the number of characters in the string S which

        * equals CHAR_PRED, if it is character,

        * satisifies the predicate CHAR_PRED, if it is a procedure.

        * is in the set CHAR_PRED, if it is a character set.

 -- Scheme Procedure: string-contains s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_contains (s1, s2, start1, end1, start2, end2)
     Does string S1 contain string S2?  Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.

 -- Scheme Procedure: string-contains-ci s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_contains_ci (s1, s2, start1, end1, start2,
          end2)
     Does string S1 contain string S2?  Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.  Character
     comparison is done case-insensitively.


File: guile.info,  Node: Alphabetic Case Mapping,  Next: Reversing and Appending Strings,  Prev: String Searching,  Up: Strings

5.5.5.9 Alphabetic Case Mapping
...............................

These are procedures for mapping strings to their upper- or lower-case
equivalents, respectively, or for capitalizing strings.

 -- Scheme Procedure: string-upcase str [start [end]]
 -- C Function: scm_substring_upcase (str, start, end)
 -- C Function: scm_string_upcase (str)
     Upcase every character in `str'.

 -- Scheme Procedure: string-upcase! str [start [end]]
 -- C Function: scm_substring_upcase_x (str, start, end)
 -- C Function: scm_string_upcase_x (str)
     Destructively upcase every character in `str'.

          (string-upcase! y)
          => "ARRDEFG"
          y
          => "ARRDEFG"

 -- Scheme Procedure: string-downcase str [start [end]]
 -- C Function: scm_substring_downcase (str, start, end)
 -- C Function: scm_string_downcase (str)
     Downcase every character in STR.

 -- Scheme Procedure: string-downcase! str [start [end]]
 -- C Function: scm_substring_downcase_x (str, start, end)
 -- C Function: scm_string_downcase_x (str)
     Destructively downcase every character in STR.

          y
          => "ARRDEFG"
          (string-downcase! y)
          => "arrdefg"
          y
          => "arrdefg"

 -- Scheme Procedure: string-capitalize str
 -- C Function: scm_string_capitalize (str)
     Return a freshly allocated string with the characters in STR,
     where the first character of every word is capitalized.

 -- Scheme Procedure: string-capitalize! str
 -- C Function: scm_string_capitalize_x (str)
     Upcase the first character of every word in STR destructively and
     return STR.

          y                      => "hello world"
          (string-capitalize! y) => "Hello World"
          y                      => "Hello World"

 -- Scheme Procedure: string-titlecase str [start [end]]
 -- C Function: scm_string_titlecase (str, start, end)
     Titlecase every first character in a word in STR.

 -- Scheme Procedure: string-titlecase! str [start [end]]
 -- C Function: scm_string_titlecase_x (str, start, end)
     Destructively titlecase every first character in a word in STR.


File: guile.info,  Node: Reversing and Appending Strings,  Next: Mapping Folding and Unfolding,  Prev: Alphabetic Case Mapping,  Up: Strings

5.5.5.10 Reversing and Appending Strings
........................................

 -- Scheme Procedure: string-reverse str [start [end]]
 -- C Function: scm_string_reverse (str, start, end)
     Reverse the string STR.  The optional arguments START and END
     delimit the region of STR to operate on.

 -- Scheme Procedure: string-reverse! str [start [end]]
 -- C Function: scm_string_reverse_x (str, start, end)
     Reverse the string STR in-place.  The optional arguments START and
     END delimit the region of STR to operate on.  The return value is
     unspecified.

 -- Scheme Procedure: string-append . args
 -- C Function: scm_string_append (args)
     Return a newly allocated string whose characters form the
     concatenation of the given strings, ARGS.

          (let ((h "hello "))
            (string-append h "world"))
          => "hello world"

 -- Scheme Procedure: string-append/shared . ls
 -- C Function: scm_string_append_shared (ls)
     Like `string-append', but the result may share memory with the
     argument strings.

 -- Scheme Procedure: string-concatenate ls
 -- C Function: scm_string_concatenate (ls)
     Append the elements of LS (which must be strings) together into a
     single string.  Guaranteed to return a freshly allocated string.

 -- Scheme Procedure: string-concatenate-reverse ls [final_string [end]]
 -- C Function: scm_string_concatenate_reverse (ls, final_string, end)
     Without optional arguments, this procedure is equivalent to

          (string-concatenate (reverse ls))

     If the optional argument FINAL_STRING is specified, it is consed
     onto the beginning to LS before performing the list-reverse and
     string-concatenate operations.  If END is given, only the
     characters of FINAL_STRING up to index END are used.

     Guaranteed to return a freshly allocated string.

 -- Scheme Procedure: string-concatenate/shared ls
 -- C Function: scm_string_concatenate_shared (ls)
     Like `string-concatenate', but the result may share memory with
     the strings in the list LS.

 -- Scheme Procedure: string-concatenate-reverse/shared ls
          [final_string [end]]
 -- C Function: scm_string_concatenate_reverse_shared (ls,
          final_string, end)
     Like `string-concatenate-reverse', but the result may share memory
     with the the strings in the LS arguments.


File: guile.info,  Node: Mapping Folding and Unfolding,  Next: Miscellaneous String Operations,  Prev: Reversing and Appending Strings,  Up: Strings

5.5.5.11 Mapping, Folding, and Unfolding
........................................

 -- Scheme Procedure: string-map proc s [start [end]]
 -- C Function: scm_string_map (proc, s, start, end)
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.

 -- Scheme Procedure: string-map! proc s [start [end]]
 -- C Function: scm_string_map_x (proc, s, start, end)
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.  The string S is modified in-place, the return value is
     not specified.

 -- Scheme Procedure: string-for-each proc s [start [end]]
 -- C Function: scm_string_for_each (proc, s, start, end)
     PROC is mapped over S in left-to-right order.  The return value is
     not specified.

 -- Scheme Procedure: string-for-each-index proc s [start [end]]
 -- C Function: scm_string_for_each_index (proc, s, start, end)
     Call `(PROC i)' for each index i in S, from left to right.

     For example, to change characters to alternately upper and lower
     case,

          (define str (string-copy "studly"))
          (string-for-each-index (lambda (i)
                                   (string-set! str i
                                     ((if (even? i) char-upcase char-downcase)
                                      (string-ref str i))))
                                 str)
          str => "StUdLy"

 -- Scheme Procedure: string-fold kons knil s [start [end]]
 -- C Function: scm_string_fold (kons, knil, s, start, end)
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from left to right.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

 -- Scheme Procedure: string-fold-right kons knil s [start [end]]
 -- C Function: scm_string_fold_right (kons, knil, s, start, end)
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from right to left.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

 -- Scheme Procedure: string-unfold p f g seed [base [make_final]]
 -- C Function: scm_string_unfold (p, f, g, seed, base, make_final)
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in
          a left-to-right order.

        * BASE is the optional initial/leftmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/rightmost portion of the
          constructed string.  The default is nothing extra.

 -- Scheme Procedure: string-unfold-right p f g seed [base [make_final]]
 -- C Function: scm_string_unfold_right (p, f, g, seed, base,
          make_final)
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in
          a right-to-left order.

        * BASE is the optional initial/rightmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/leftmost portion of the
          constructed string.  It defaults to `(lambda (x) )'.


File: guile.info,  Node: Miscellaneous String Operations,  Next: Conversion to/from C,  Prev: Mapping Folding and Unfolding,  Up: Strings

5.5.5.12 Miscellaneous String Operations
........................................

 -- Scheme Procedure: xsubstring s from [to [start [end]]]
 -- C Function: scm_xsubstring (s, from, to, start, end)
     This is the _extended substring_ procedure that implements
     replicated copying of a substring of some string.

     S is a string, START and END are optional arguments that demarcate
     a substring of S, defaulting to 0 and the length of S.  Replicate
     this substring up and down index space, in both the positive and
     negative directions.  `xsubstring' returns the substring of this
     string beginning at index FROM, and ending at TO, which defaults
     to FROM + (END - START).

 -- Scheme Procedure: string-xcopy! target tstart s sfrom [sto [start
          [end]]]
 -- C Function: scm_string_xcopy_x (target, tstart, s, sfrom, sto,
          start, end)
     Exactly the same as `xsubstring', but the extracted text is
     written into the string TARGET starting at index TSTART.  The
     operation is not defined if `(eq?  TARGET S)' or these arguments
     share storage - you cannot copy a string on top of itself.

 -- Scheme Procedure: string-replace s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_replace (s1, s2, start1, end1, start2, end2)
     Return the string S1, but with the characters START1 ... END1
     replaced by the characters START2 ... END2 from S2.

 -- Scheme Procedure: string-tokenize s [token_set [start [end]]]
 -- C Function: scm_string_tokenize (s, token_set, start, end)
     Split the string S into a list of substrings, where each substring
     is a maximal non-empty contiguous sequence of characters from the
     character set TOKEN_SET, which defaults to `char-set:graphic'.  If
     START or END indices are provided, they restrict `string-tokenize'
     to operating on the indicated substring of S.

 -- Scheme Procedure: string-filter s char_pred [start [end]]
 -- C Function: scm_string_filter (s, char_pred, start, end)
     Filter the string S, retaining only those characters which satisfy
     CHAR_PRED.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.

 -- Scheme Procedure: string-delete s char_pred [start [end]]
 -- C Function: scm_string_delete (s, char_pred, start, end)
     Delete characters satisfying CHAR_PRED from S.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.


File: guile.info,  Node: Conversion to/from C,  Prev: Miscellaneous String Operations,  Up: Strings

5.5.5.13 Conversion to/from C
.............................

When creating a Scheme string from a C string or when converting a
Scheme string to a C string, the concept of character encoding becomes
important.

   In C, a string is just a sequence of bytes, and the character
encoding describes the relation between these bytes and the actual
characters that make up the string.  For Scheme strings, character
encoding is not an issue (most of the time), since in Scheme you never
get to see the bytes, only the characters.

   Well, ideally, anyway.  Right now, Guile simply equates Scheme
characters and bytes, ignoring the possibility of multi-byte encodings
completely.  This will change in the future, where Guile will use
Unicode codepoints as its characters and UTF-8 or some other encoding
as its internal encoding.  When you exclusively use the functions
listed in this section, you are `future-proof'.

   Converting a Scheme string to a C string will often allocate fresh
memory to hold the result.  You must take care that this memory is
properly freed eventually.  In many cases, this can be achieved by
using `scm_dynwind_free' inside an appropriate dynwind context, *Note
Dynamic Wind::.

 -- C Function: SCM scm_from_locale_string (const char *str)
 -- C Function: SCM scm_from_locale_stringn (const char *str, size_t
          len)
     Creates a new Scheme string that has the same contents as STR when
     interpreted in the current locale character encoding.

     For `scm_from_locale_string', STR must be null-terminated.

     For `scm_from_locale_stringn', LEN specifies the length of STR in
     bytes, and STR does not need to be null-terminated.  If LEN is
     `(size_t)-1', then STR does need to be null-terminated and the
     real length will be found with `strlen'.

 -- C Function: SCM scm_take_locale_string (char *str)
 -- C Function: SCM scm_take_locale_stringn (char *str, size_t len)
     Like `scm_from_locale_string' and `scm_from_locale_stringn',
     respectively, but also frees STR with `free' eventually.  Thus,
     you can use this function when you would free STR anyway
     immediately after creating the Scheme string.  In certain cases,
     Guile can then use STR directly as its internal representation.

 -- C Function: char * scm_to_locale_string (SCM str)
 -- C Function: char * scm_to_locale_stringn (SCM str, size_t *lenp)
     Returns a C string in the current locale encoding with the same
     contents as STR.  The C string must be freed with `free'
     eventually, maybe by using `scm_dynwind_free', *Note Dynamic
     Wind::.

     For `scm_to_locale_string', the returned string is null-terminated
     and an error is signalled when STR contains `#\nul' characters.

     For `scm_to_locale_stringn' and LENP not `NULL', STR might contain
     `#\nul' characters and the length of the returned string in bytes
     is stored in `*LENP'.  The returned string will not be
     null-terminated in this case.  If LENP is `NULL',
     `scm_to_locale_stringn' behaves like `scm_to_locale_string'.

 -- C Function: size_t scm_to_locale_stringbuf (SCM str, char *buf,
          size_t max_len)
     Puts STR as a C string in the current locale encoding into the
     memory pointed to by BUF.  The buffer at BUF has room for MAX_LEN
     bytes and `scm_to_local_stringbuf' will never store more than
     that.  No terminating `'\0'' will be stored.

     The return value of `scm_to_locale_stringbuf' is the number of
     bytes that are needed for all of STR, regardless of whether BUF
     was large enough to hold them.  Thus, when the return value is
     larger than MAX_LEN, only MAX_LEN bytes have been stored and you
     probably need to try again with a larger buffer.


File: guile.info,  Node: Regular Expressions,  Next: Symbols,  Prev: Strings,  Up: Simple Data Types

5.5.6 Regular Expressions
-------------------------

A "regular expression" (or "regexp") is a pattern that describes a
whole class of strings.  A full description of regular expressions and
their syntax is beyond the scope of this manual; an introduction can be
found in the Emacs manual (*note Syntax of Regular Expressions:
(emacs)Regexps.), or in many general Unix reference books.

   If your system does not include a POSIX regular expression library,
and you have not linked Guile with a third-party regexp library such as
Rx, these functions will not be available.  You can tell whether your
Guile installation includes regular expression support by checking
whether `(provided? 'regex)' returns true.

   The following regexp and string matching features are provided by the
`(ice-9 regex)' module.  Before using the described functions, you
should load this module by executing `(use-modules (ice-9 regex))'.

* Menu:

* Regexp Functions::            Functions that create and match regexps.
* Match Structures::            Finding what was matched by a regexp.
* Backslash Escapes::           Removing the special meaning of regexp
                                meta-characters.


File: guile.info,  Node: Regexp Functions,  Next: Match Structures,  Up: Regular Expressions

5.5.6.1 Regexp Functions
........................

By default, Guile supports POSIX extended regular expressions.  That
means that the characters `(', `)', `+' and `?' are special, and must
be escaped if you wish to match the literal characters.

   This regular expression interface was modeled after that implemented
by SCSH, the Scheme Shell.  It is intended to be upwardly compatible
with SCSH regular expressions.

   Zero bytes (`#\nul') cannot be used in regex patterns or input
strings, since the underlying C functions treat that as the end of
string.  If there's a zero byte an error is thrown.

   Patterns and input strings are treated as being in the locale
character set if `setlocale' has been called (*note Locales::), and in
a multibyte locale this includes treating multi-byte sequences as a
single character.  (Guile strings are currently merely bytes, though
this may change in the future, *Note Conversion to/from C::.)

 -- Scheme Procedure: string-match pattern str [start]
     Compile the string PATTERN into a regular expression and compare
     it with STR.  The optional numeric argument START specifies the
     position of STR at which to begin matching.

     `string-match' returns a "match structure" which describes what,
     if anything, was matched by the regular expression.  *Note Match
     Structures::.  If STR does not match PATTERN at all,
     `string-match' returns `#f'.

   Two examples of a match follow.  In the first example, the pattern
matches the four digits in the match string.  In the second, the pattern
matches nothing.

     (string-match "[0-9][0-9][0-9][0-9]" "blah2002")
     => #("blah2002" (4 . 8))

     (string-match "[A-Za-z]" "123456")
     => #f

   Each time `string-match' is called, it must compile its PATTERN
argument into a regular expression structure.  This operation is
expensive, which makes `string-match' inefficient if the same regular
expression is used several times (for example, in a loop).  For better
performance, you can compile a regular expression in advance and then
match strings against the compiled regexp.

 -- Scheme Procedure: make-regexp pat flag...
 -- C Function: scm_make_regexp (pat, flaglst)
     Compile the regular expression described by PAT, and return the
     compiled regexp structure.  If PAT does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     The FLAG arguments change the behavior of the compiled regular
     expression.  The following values may be supplied:

      -- Variable: regexp/icase
          Consider uppercase and lowercase letters to be the same when
          matching.

      -- Variable: regexp/newline
          If a newline appears in the target string, then permit the
          `^' and `$' operators to match immediately after or
          immediately before the newline, respectively.  Also, the `.'
          and `[^...]' operators will never match a newline character.
          The intent of this flag is to treat the target string as a
          buffer containing many lines of text, and the regular
          expression as a pattern that may match a single one of those
          lines.

      -- Variable: regexp/basic
          Compile a basic ("obsolete") regexp instead of the extended
          ("modern") regexps that are the default.  Basic regexps do
          not consider `|', `+' or `?' to be special characters, and
          require the `{...}' and `(...)' metacharacters to be
          backslash-escaped (*note Backslash Escapes::).  There are
          several other differences between basic and extended regular
          expressions, but these are the most significant.

      -- Variable: regexp/extended
          Compile an extended regular expression rather than a basic
          regexp.  This is the default behavior; this flag will not
          usually be needed.  If a call to `make-regexp' includes both
          `regexp/basic' and `regexp/extended' flags, the one which
          comes last will override the earlier one.

 -- Scheme Procedure: regexp-exec rx str [start [flags]]
 -- C Function: scm_regexp_exec (rx, str, start, flags)
     Match the compiled regular expression RX against `str'.  If the
     optional integer START argument is provided, begin matching from
     that position in the string.  Return a match structure describing
     the results of the match, or `#f' if no match could be found.

     The FLAGS argument changes the matching behavior.  The following
     flag values may be supplied, use `logior' (*note Bitwise
     Operations::) to combine them,

      -- Variable: regexp/notbol
          Consider that the START offset into STR is not the beginning
          of a line and should not match operator `^'.

          If RX was created with the `regexp/newline' option above, `^'
          will still match after a newline in STR.

      -- Variable: regexp/noteol
          Consider that the end of STR is not the end of a line and
          should not match operator `$'.

          If RX was created with the `regexp/newline' option above, `$'
          will still match before a newline in STR.

     ;; Regexp to match uppercase letters
     (define r (make-regexp "[A-Z]*"))

     ;; Regexp to match letters, ignoring case
     (define ri (make-regexp "[A-Z]*" regexp/icase))

     ;; Search for bob using regexp r
     (match:substring (regexp-exec r "bob"))
     => ""                  ; no match

     ;; Search for bob using regexp ri
     (match:substring (regexp-exec ri "Bob"))
     => "Bob"               ; matched case insensitive

 -- Scheme Procedure: regexp? obj
 -- C Function: scm_regexp_p (obj)
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.


 -- Scheme Procedure: list-matches regexp str [flags]
     Return a list of match structures which are the non-overlapping
     matches of REGEXP in STR.  REGEXP can be either a pattern string
     or a compiled regexp.  The FLAGS argument is as per `regexp-exec'
     above.

          (map match:substring (list-matches "[a-z]+" "abc 42 def 78"))
          => ("abc" "def")

 -- Scheme Procedure: fold-matches regexp str init proc [flags]
     Apply PROC to the non-overlapping matches of REGEXP in STR, to
     build a result.  REGEXP can be either a pattern string or a
     compiled regexp.  The FLAGS argument is as per `regexp-exec' above.

     PROC is called as `(PROC match prev)' where MATCH is a match
     structure and PREV is the previous return from PROC.  For the
     first call PREV is the given INIT parameter.  `fold-matches'
     returns the final value from PROC.

     For example to count matches,

          (fold-matches "[a-z][0-9]" "abc x1 def y2" 0
                        (lambda (match count)
                          (1+ count)))
          => 2


   Regular expressions are commonly used to find patterns in one string
and replace them with the contents of another string.  The following
functions are convenient ways to do this.

 -- Scheme Procedure: regexp-substitute port match [item...]
     Write to PORT selected parts of the match structure MATCH.  Or if
     PORT is `#f' then form a string from those parts and return that.

     Each ITEM specifies a part to be written, and may be one of the
     following,

        * A string.  String arguments are written out verbatim.

        * An integer.  The submatch with that number is written
          (`match:substring').  Zero is the entire match.

        * The symbol `pre'.  The portion of the matched string preceding
          the regexp match is written (`match:prefix').

        * The symbol `post'.  The portion of the matched string
          following the regexp match is written (`match:suffix').

     For example, changing a match and retaining the text before and
     after,

          (regexp-substitute #f (string-match "[0-9]+" "number 25 is good")
                             'pre "37" 'post)
          => "number 37 is good"

     Or matching a YYYYMMDD format date such as `20020828' and
     re-ordering and hyphenating the fields.

          (define date-regex "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
          (define s "Date 20020429 12am.")
          (regexp-substitute #f (string-match date-regex s)
                             'pre 2 "-" 3 "-" 1 'post " (" 0 ")")
          => "Date 04-29-2002 12am. (20020429)"

 -- Scheme Procedure: regexp-substitute/global port regexp target
          [item...]
     Write to PORT selected parts of matches of REGEXP in TARGET.  If
     PORT is `#f' then form a string from those parts and return that.
     REGEXP can be a string or a compiled regex.

     This is similar to `regexp-substitute', but allows global
     substitutions on TARGET.  Each ITEM behaves as per
     `regexp-substitute', with the following differences,

        * A function.  Called as `(ITEM match)' with the match
          structure for the REGEXP match, it should return a string to
          be written to PORT.

        * The symbol `post'.  This doesn't output anything, but instead
          causes `regexp-substitute/global' to recurse on the unmatched
          portion of TARGET.

          This _must_ be supplied to perform a global search and
          replace on TARGET; without it `regexp-substitute/global'
          returns after a single match and output.

     For example, to collapse runs of tabs and spaces to a single hyphen
     each,

          (regexp-substitute/global #f "[ \t]+"  "this   is   the text"
                                    'pre "-" 'post)
          => "this-is-the-text"

     Or using a function to reverse the letters in each word,

          (regexp-substitute/global #f "[a-z]+"  "to do and not-do"
            'pre (lambda (m) (string-reverse (match:substring m))) 'post)
          => "ot od dna ton-od"

     Without the `post' symbol, just one regexp match is made.  For
     example the following is the date example from `regexp-substitute'
     above, without the need for the separate `string-match' call.

          (define date-regex "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
          (define s "Date 20020429 12am.")
          (regexp-substitute/global #f date-regex s
                                    'pre 2 "-" 3 "-" 1 'post " (" 0 ")")

          => "Date 04-29-2002 12am. (20020429)"


File: guile.info,  Node: Match Structures,  Next: Backslash Escapes,  Prev: Regexp Functions,  Up: Regular Expressions

5.5.6.2 Match Structures
........................

A "match structure" is the object returned by `string-match' and
`regexp-exec'.  It describes which portion of a string, if any, matched
the given regular expression.  Match structures include: a reference to
the string that was checked for matches; the starting and ending
positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

   In each of the regexp match functions described below, the `match'
argument must be a match structure returned by a previous call to
`string-match' or `regexp-exec'.  Most of these functions return some
information about the original target string that was matched against a
regular expression; we will call that string TARGET for easy reference.

 -- Scheme Procedure: regexp-match? obj
     Return `#t' if OBJ is a match structure returned by a previous
     call to `regexp-exec', or `#f' otherwise.

 -- Scheme Procedure: match:substring match [n]
     Return the portion of TARGET matched by subexpression number N.
     Submatch 0 (the default) represents the entire regexp match.  If
     the regular expression as a whole matched, but the subexpression
     number N did not match, return `#f'.

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:substring s)
     => "2002"

     ;; match starting at offset 6 in the string
     (match:substring
       (string-match "[0-9][0-9][0-9][0-9]" "blah987654" 6))
     => "7654"

 -- Scheme Procedure: match:start match [n]
     Return the starting position of submatch number N.

   In the following example, the result is 4, since the match starts at
character index 4:

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:start s)
     => 4

 -- Scheme Procedure: match:end match [n]
     Return the ending position of submatch number N.

   In the following example, the result is 8, since the match runs
between characters 4 and 8 (i.e. the "2002").

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:end s)
     => 8

 -- Scheme Procedure: match:prefix match
     Return the unmatched portion of TARGET preceding the regexp match.

          (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
          (match:prefix s)
          => "blah"

 -- Scheme Procedure: match:suffix match
     Return the unmatched portion of TARGET following the regexp match.

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:suffix s)
     => "foo"

 -- Scheme Procedure: match:count match
     Return the number of parenthesized subexpressions from MATCH.
     Note that the entire regular expression match itself counts as a
     subexpression, and failed submatches are included in the count.

 -- Scheme Procedure: match:string match
     Return the original TARGET string.

     (define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
     (match:string s)
     => "blah2002foo"


File: guile.info,  Node: Backslash Escapes,  Prev: Match Structures,  Up: Regular Expressions

5.5.6.3 Backslash Escapes
.........................

Sometimes you will want a regexp to match characters like `*' or `$'
exactly.  For example, to check whether a particular string represents
a menu entry from an Info node, it would be useful to match it against
a regexp like `^* [^:]*::'.  However, this won't work; because the
asterisk is a metacharacter, it won't match the `*' at the beginning of
the string.  In this case, we want to make the first asterisk un-magic.

   You can do this by preceding the metacharacter with a backslash
character `\'.  (This is also called "quoting" the metacharacter, and
is known as a "backslash escape".)  When Guile sees a backslash in a
regular expression, it considers the following glyph to be an ordinary
character, no matter what special meaning it would ordinarily have.
Therefore, we can make the above example work by changing the regexp to
`^\* [^:]*::'.  The `\*' sequence tells the regular expression engine
to match only a single asterisk in the target string.

   Since the backslash is itself a metacharacter, you may force a
regexp to match a backslash in the target string by preceding the
backslash with itself.  For example, to find variable references in a
TeX program, you might want to find occurrences of the string `\let\'
followed by any number of alphabetic characters.  The regular expression
`\\let\\[A-Za-z]*' would do this: the double backslashes in the regexp
each match a single backslash in the target string.

 -- Scheme Procedure: regexp-quote str
     Quote each special character found in STR with a backslash, and
     return the resulting string.

   *Very important:* Using backslash escapes in Guile source code (as
in Emacs Lisp or C) can be tricky, because the backslash character has
special meaning for the Guile reader.  For example, if Guile encounters
the character sequence `\n' in the middle of a string while processing
Scheme code, it replaces those characters with a newline character.
Similarly, the character sequence `\t' is replaced by a horizontal tab.
Several of these "escape sequences" are processed by the Guile reader
before your code is executed.  Unrecognized escape sequences are
ignored: if the characters `\*' appear in a string, they will be
translated to the single character `*'.

   This translation is obviously undesirable for regular expressions,
since we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use _two_
consecutive backslashes:

     (define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))

   The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to `make-regexp' is the
string `^\* [^:]*', which is what we really want.

   This also means that in order to write a regular expression that
matches a single backslash character, the regular expression string in
the source code must include _four_ backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

     (define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))

   The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings described
above.  The POSIX regular expression specification and ANSI C standard
both require these semantics.  Attempting to abandon either convention
would cause other kinds of compatibility problems, possibly more severe
ones.  Therefore, without extending the Scheme reader to support
strings with different quoting conventions (an ungainly and confusing
extension when implemented in other languages), we must adhere to this
cumbersome escape syntax.


File: guile.info,  Node: Symbols,  Next: Keywords,  Prev: Regular Expressions,  Up: Simple Data Types

5.5.7 Symbols
-------------

Symbols in Scheme are widely used in three ways: as items of discrete
data, as lookup keys for alists and hash tables, and to denote variable
references.

   A "symbol" is similar to a string in that it is defined by a
sequence of characters.  The sequence of characters is known as the
symbol's "name".  In the usual case -- that is, where the symbol's name
doesn't include any characters that could be confused with other
elements of Scheme syntax -- a symbol is written in a Scheme program by
writing the sequence of characters that make up the name, _without_ any
quotation marks or other special syntax.  For example, the symbol whose
name is "multiply-by-2" is written, simply:

     multiply-by-2

   Notice how this differs from a _string_ with contents
"multiply-by-2", which is written with double quotation marks, like
this:

     "multiply-by-2"

   Looking beyond how they are written, symbols are different from
strings in two important respects.

   The first important difference is uniqueness.  If the same-looking
string is read twice from two different places in a program, the result
is two _different_ string objects whose contents just happen to be the
same.  If, on the other hand, the same-looking symbol is read twice
from two different places in a program, the result is the _same_ symbol
object both times.

   Given two read symbols, you can use `eq?' to test whether they are
the same (that is, have the same name).  `eq?' is the most efficient
comparison operator in Scheme, and comparing two symbols like this is
as fast as comparing, for example, two numbers.  Given two strings, on
the other hand, you must use `equal?' or `string=?', which are much
slower comparison operators, to determine whether the strings have the
same contents.

     (define sym1 (quote hello))
     (define sym2 (quote hello))
     (eq? sym1 sym2) => #t

     (define str1 "hello")
     (define str2 "hello")
     (eq? str1 str2) => #f
     (equal? str1 str2) => #t

   The second important difference is that symbols, unlike strings, are
not self-evaluating.  This is why we need the `(quote ...)'s in the
example above: `(quote hello)' evaluates to the symbol named "hello"
itself, whereas an unquoted `hello' is _read_ as the symbol named
"hello" and evaluated as a variable reference ... about which more
below (*note Symbol Variables::).

* Menu:

* Symbol Data::                 Symbols as discrete data.
* Symbol Keys::                 Symbols as lookup keys.
* Symbol Variables::            Symbols as denoting variables.
* Symbol Primitives::           Operations related to symbols.
* Symbol Props::                Function slots and property lists.
* Symbol Read Syntax::          Extended read syntax for symbols.
* Symbol Uninterned::           Uninterned symbols.


File: guile.info,  Node: Symbol Data,  Next: Symbol Keys,  Up: Symbols

5.5.7.1 Symbols as Discrete Data
................................

Numbers and symbols are similar to the extent that they both lend
themselves to `eq?' comparison.  But symbols are more descriptive than
numbers, because a symbol's name can be used directly to describe the
concept for which that symbol stands.

   For example, imagine that you need to represent some colours in a
computer program.  Using numbers, you would have to choose arbitrarily
some mapping between numbers and colours, and then take care to use that
mapping consistently:

     ;; 1=red, 2=green, 3=purple

     (if (eq? (colour-of car) 1)
         ...)

You can make the mapping more explicit and the code more readable by
defining constants:

     (define red 1)
     (define green 2)
     (define purple 3)

     (if (eq? (colour-of car) red)
         ...)

But the simplest and clearest approach is not to use numbers at all, but
symbols whose names specify the colours that they refer to:

     (if (eq? (colour-of car) 'red)
         ...)

   The descriptive advantages of symbols over numbers increase as the
set of concepts that you want to describe grows.  Suppose that a car
object can have other properties as well, such as whether it has or
uses:

   * automatic or manual transmission

   * leaded or unleaded fuel

   * power steering (or not).

Then a car's combined property set could be naturally represented and
manipulated as a list of symbols:

     (properties-of car1)
     =>
     (red manual unleaded power-steering)

     (if (memq 'power-steering (properties-of car1))
         (display "Unfit people can drive this car.\n")
         (display "You'll need strong arms to drive this car!\n"))
     -|
     Unfit people can drive this car.

   Remember, the fundamental property of symbols that we are relying on
here is that an occurrence of `'red' in one part of a program is an
_indistinguishable_ symbol from an occurrence of `'red' in another part
of a program; this means that symbols can usefully be compared using
`eq?'.  At the same time, symbols have naturally descriptive names.
This combination of efficiency and descriptive power makes them ideal
for use as discrete data.


File: guile.info,  Node: Symbol Keys,  Next: Symbol Variables,  Prev: Symbol Data,  Up: Symbols

5.5.7.2 Symbols as Lookup Keys
..............................

Given their efficiency and descriptive power, it is natural to use
symbols as the keys in an association list or hash table.

   To illustrate this, consider a more structured representation of the
car properties example from the preceding subsection.  Rather than
mixing all the properties up together in a flat list, we could use an
association list like this:

     (define car1-properties '((colour . red)
                               (transmission . manual)
                               (fuel . unleaded)
                               (steering . power-assisted)))

   Notice how this structure is more explicit and extensible than the
flat list.  For example it makes clear that `manual' refers to the
transmission rather than, say, the windows or the locking of the car.
It also allows further properties to use the same symbols among their
possible values without becoming ambiguous:

     (define car1-properties '((colour . red)
                               (transmission . manual)
                               (fuel . unleaded)
                               (steering . power-assisted)
                               (seat-colour . red)
                               (locking . manual)))

   With a representation like this, it is easy to use the efficient
`assq-XXX' family of procedures (*note Association Lists::) to extract
or change individual pieces of information:

     (assq-ref car1-properties 'fuel) => unleaded
     (assq-ref car1-properties 'transmission) => manual

     (assq-set! car1-properties 'seat-colour 'black)
     =>
     ((colour . red)
      (transmission . manual)
      (fuel . unleaded)
      (steering . power-assisted)
      (seat-colour . black)
      (locking . manual)))

   Hash tables also have keys, and exactly the same arguments apply to
the use of symbols in hash tables as in association lists.  The hash
value that Guile uses to decide where to add a symbol-keyed entry to a
hash table can be obtained by calling the `symbol-hash' procedure:

 -- Scheme Procedure: symbol-hash symbol
 -- C Function: scm_symbol_hash (symbol)
     Return a hash value for SYMBOL.

   See *note Hash Tables:: for information about hash tables in
general, and for why you might choose to use a hash table rather than
an association list.


File: guile.info,  Node: Symbol Variables,  Next: Symbol Primitives,  Prev: Symbol Keys,  Up: Symbols

5.5.7.3 Symbols as Denoting Variables
.....................................

When an unquoted symbol in a Scheme program is evaluated, it is
interpreted as a variable reference, and the result of the evaluation is
the appropriate variable's value.

   For example, when the expression `(string-length "abcd")' is read
and evaluated, the sequence of characters `string-length' is read as
the symbol whose name is "string-length".  This symbol is associated
with a variable whose value is the procedure that implements string
length calculation.  Therefore evaluation of the `string-length' symbol
results in that procedure.

   The details of the connection between an unquoted symbol and the
variable to which it refers are explained elsewhere.  See *note Binding
Constructs::, for how associations between symbols and variables are
created, and *note Modules::, for how those associations are affected by
Guile's module system.


File: guile.info,  Node: Symbol Primitives,  Next: Symbol Props,  Prev: Symbol Variables,  Up: Symbols

5.5.7.4 Operations Related to Symbols
.....................................

Given any Scheme value, you can determine whether it is a symbol using
the `symbol?' primitive:

 -- Scheme Procedure: symbol? obj
 -- C Function: scm_symbol_p (obj)
     Return `#t' if OBJ is a symbol, otherwise return `#f'.

 -- C Function: int scm_is_symbol (SCM val)
     Equivalent to `scm_is_true (scm_symbol_p (val))'.

   Once you know that you have a symbol, you can obtain its name as a
string by calling `symbol->string'.  Note that Guile differs by default
from R5RS on the details of `symbol->string' as regards
case-sensitivity:

 -- Scheme Procedure: symbol->string s
 -- C Function: scm_symbol_to_string (s)
     Return the name of symbol S as a string.  By default, Guile reads
     symbols case-sensitively, so the string returned will have the
     same case variation as the sequence of characters that caused S to
     be created.

     If Guile is set to read symbols case-insensitively (as specified by
     R5RS), and S comes into being as part of a literal expression
     (*note Literal expressions: (r5rs)Literal expressions.) or by a
     call to the `read' or `string-ci->symbol' procedures, Guile
     converts any alphabetic characters in the symbol's name to lower
     case before creating the symbol object, so the string returned
     here will be in lower case.

     If S was created by `string->symbol', the case of characters in
     the string returned will be the same as that in the string that was
     passed to `string->symbol', regardless of Guile's case-sensitivity
     setting at the time S was created.

     It is an error to apply mutation procedures like `string-set!' to
     strings returned by this procedure.

   Most symbols are created by writing them literally in code.  However
it is also possible to create symbols programmatically using the
following `string->symbol' and `string-ci->symbol' procedures:

 -- Scheme Procedure: string->symbol string
 -- C Function: scm_string_to_symbol (string)
     Return the symbol whose name is STRING.  This procedure can create
     symbols with names containing special characters or letters in the
     non-standard case, but it is usually a bad idea to create such
     symbols because in some implementations of Scheme they cannot be
     read as themselves.

 -- Scheme Procedure: string-ci->symbol str
 -- C Function: scm_string_ci_to_symbol (str)
     Return the symbol whose name is STR.  If Guile is currently
     reading symbols case-insensitively, STR is converted to lowercase
     before the returned symbol is looked up or created.

   The following examples illustrate Guile's detailed behaviour as
regards the case-sensitivity of symbols:

     (read-enable 'case-insensitive)   ; R5RS compliant behaviour

     (symbol->string 'flying-fish)    => "flying-fish"
     (symbol->string 'Martin)         => "martin"
     (symbol->string
        (string->symbol "Malvina"))   => "Malvina"

     (eq? 'mISSISSIppi 'mississippi)  => #t
     (string->symbol "mISSISSIppi")   => mISSISSIppi
     (eq? 'bitBlt (string->symbol "bitBlt")) => #f
     (eq? 'LolliPop
       (string->symbol (symbol->string 'LolliPop))) => #t
     (string=? "K. Harper, M.D."
       (symbol->string
         (string->symbol "K. Harper, M.D."))) => #t

     (read-disable 'case-insensitive)   ; Guile default behaviour

     (symbol->string 'flying-fish)    => "flying-fish"
     (symbol->string 'Martin)         => "Martin"
     (symbol->string
        (string->symbol "Malvina"))   => "Malvina"

     (eq? 'mISSISSIppi 'mississippi)  => #f
     (string->symbol "mISSISSIppi")   => mISSISSIppi
     (eq? 'bitBlt (string->symbol "bitBlt")) => #t
     (eq? 'LolliPop
       (string->symbol (symbol->string 'LolliPop))) => #t
     (string=? "K. Harper, M.D."
       (symbol->string
         (string->symbol "K. Harper, M.D."))) => #t

   From C, there are lower level functions that construct a Scheme
symbol from a C string in the current locale encoding.

   When you want to do more from C, you should convert between symbols
and strings using `scm_symbol_to_string' and `scm_string_to_symbol' and
work with the strings.

 -- C Function: scm_from_locale_symbol (const char *name)
 -- C Function: scm_from_locale_symboln (const char *name, size_t len)
     Construct and return a Scheme symbol whose name is specified by
     NAME.  For `scm_from_locale_symbol', NAME must be null terminated;
     for `scm_from_locale_symboln' the length of NAME is specified
     explicitly by LEN.

 -- C Function: SCM scm_take_locale_symbol (char *str)
 -- C Function: SCM scm_take_locale_symboln (char *str, size_t len)
     Like `scm_from_locale_symbol' and `scm_from_locale_symboln',
     respectively, but also frees STR with `free' eventually.  Thus,
     you can use this function when you would free STR anyway
     immediately after creating the Scheme string.  In certain cases,
     Guile can then use STR directly as its internal representation.

   The size of a symbol can also be obtained from C:

 -- C Function: size_t scm_c_symbol_length (SCM sym)
     Return the number of characters in SYM.

   Finally, some applications, especially those that generate new Scheme
code dynamically, need to generate symbols for use in the generated
code.  The `gensym' primitive meets this need:

 -- Scheme Procedure: gensym [prefix]
 -- C Function: scm_gensym (prefix)
     Create a new symbol with a name constructed from a prefix and a
     counter value.  The string PREFIX can be specified as an optional
     argument.  Default prefix is ` g'.  The counter is increased by 1
     at each call.  There is no provision for resetting the counter.

   The symbols generated by `gensym' are _likely_ to be unique, since
their names begin with a space and it is only otherwise possible to
generate such symbols if a programmer goes out of their way to do so.
Uniqueness can be guaranteed by instead using uninterned symbols (*note
Symbol Uninterned::), though they can't be usefully written out and
read back in.


File: guile.info,  Node: Symbol Props,  Next: Symbol Read Syntax,  Prev: Symbol Primitives,  Up: Symbols

5.5.7.5 Function Slots and Property Lists
.........................................

In traditional Lisp dialects, symbols are often understood as having
three kinds of value at once:

   * a "variable" value, which is used when the symbol appears in code
     in a variable reference context

   * a "function" value, which is used when the symbol appears in code
     in a function name position (i.e. as the first element in an
     unquoted list)

   * a "property list" value, which is used when the symbol is given as
     the first argument to Lisp's `put' or `get' functions.

   Although Scheme (as one of its simplifications with respect to Lisp)
does away with the distinction between variable and function namespaces,
Guile currently retains some elements of the traditional structure in
case they turn out to be useful when implementing translators for other
languages, in particular Emacs Lisp.

   Specifically, Guile symbols have two extra slots. for a symbol's
property list, and for its "function value."  The following procedures
are provided to access these slots.

 -- Scheme Procedure: symbol-fref symbol
 -- C Function: scm_symbol_fref (symbol)
     Return the contents of SYMBOL's "function slot".

 -- Scheme Procedure: symbol-fset! symbol value
 -- C Function: scm_symbol_fset_x (symbol, value)
     Set the contents of SYMBOL's function slot to VALUE.

 -- Scheme Procedure: symbol-pref symbol
 -- C Function: scm_symbol_pref (symbol)
     Return the "property list" currently associated with SYMBOL.

 -- Scheme Procedure: symbol-pset! symbol value
 -- C Function: scm_symbol_pset_x (symbol, value)
     Set SYMBOL's property list to VALUE.

 -- Scheme Procedure: symbol-property sym prop
     From SYM's property list, return the value for property PROP.  The
     assumption is that SYM's property list is an association list
     whose keys are distinguished from each other using `equal?'; PROP
     should be one of the keys in that list.  If the property list has
     no entry for PROP, `symbol-property' returns `#f'.

 -- Scheme Procedure: set-symbol-property! sym prop val
     In SYM's property list, set the value for property PROP to VAL, or
     add a new entry for PROP, with value VAL, if none already exists.
     For the structure of the property list, see `symbol-property'.

 -- Scheme Procedure: symbol-property-remove! sym prop
     From SYM's property list, remove the entry for property PROP, if
     there is one.  For the structure of the property list, see
     `symbol-property'.

   Support for these extra slots may be removed in a future release,
and it is probably better to avoid using them.  For a more modern and
Schemely approach to properties, see *note Object Properties::.


File: guile.info,  Node: Symbol Read Syntax,  Next: Symbol Uninterned,  Prev: Symbol Props,  Up: Symbols

5.5.7.6 Extended Read Syntax for Symbols
........................................

The read syntax for a symbol is a sequence of letters, digits, and
"extended alphabetic characters", beginning with a character that
cannot begin a number.  In addition, the special cases of `+', `-', and
`...' are read as symbols even though numbers can begin with `+', `-'
or `.'.

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The set of extended alphabetic characters is:

     ! $ % & * + - . / : < = > ? @ ^ _ ~

   In addition to the standard read syntax defined above (which is taken
from R5RS (*note Formal syntax: (r5rs)Formal syntax.)), Guile provides
an extended symbol read syntax that allows the inclusion of unusual
characters such as space characters, newlines and parentheses.  If (for
whatever reason) you need to write a symbol containing characters not
mentioned above, you can do so as follows.

   * Begin the symbol with the characters `#{',

   * write the characters of the symbol and

   * finish the symbol with the characters `}#'.

   Here are a few examples of this form of read syntax.  The first
symbol needs to use extended syntax because it contains a space
character, the second because it contains a line break, and the last
because it looks like a number.

     #{foo bar}#

     #{what
     ever}#

     #{4242}#

   Although Guile provides this extended read syntax for symbols,
widespread usage of it is discouraged because it is not portable and not
very readable.


File: guile.info,  Node: Symbol Uninterned,  Prev: Symbol Read Syntax,  Up: Symbols

5.5.7.7 Uninterned Symbols
..........................

What makes symbols useful is that they are automatically kept unique.
There are no two symbols that are distinct objects but have the same
name.  But of course, there is no rule without exception.  In addition
to the normal symbols that have been discussed up to now, you can also
create special "uninterned" symbols that behave slightly differently.

   To understand what is different about them and why they might be
useful, we look at how normal symbols are actually kept unique.

   Whenever Guile wants to find the symbol with a specific name, for
example during `read' or when executing `string->symbol', it first
looks into a table of all existing symbols to find out whether a symbol
with the given name already exists.  When this is the case, Guile just
returns that symbol.  When not, a new symbol with the name is created
and entered into the table so that it can be found later.

   Sometimes you might want to create a symbol that is guaranteed
`fresh', i.e. a symbol that did not exist previously.  You might also
want to somehow guarantee that no one else will ever unintentionally
stumble across your symbol in the future.  These properties of a symbol
are often needed when generating code during macro expansion.  When
introducing new temporary variables, you want to guarantee that they
don't conflict with variables in other people's code.

   The simplest way to arrange for this is to create a new symbol but
not enter it into the global table of all symbols.  That way, no one
will ever get access to your symbol by chance.  Symbols that are not in
the table are called "uninterned".  Of course, symbols that _are_ in
the table are called "interned".

   You create new uninterned symbols with the function `make-symbol'.
You can test whether a symbol is interned or not with
`symbol-interned?'.

   Uninterned symbols break the rule that the name of a symbol uniquely
identifies the symbol object.  Because of this, they can not be written
out and read back in like interned symbols.  Currently, Guile has no
support for reading uninterned symbols.  Note that the function
`gensym' does not return uninterned symbols for this reason.

 -- Scheme Procedure: make-symbol name
 -- C Function: scm_make_symbol (name)
     Return a new uninterned symbol with the name NAME.  The returned
     symbol is guaranteed to be unique and future calls to
     `string->symbol' will not return it.

 -- Scheme Procedure: symbol-interned? symbol
 -- C Function: scm_symbol_interned_p (symbol)
     Return `#t' if SYMBOL is interned, otherwise return `#f'.

   For example:

     (define foo-1 (string->symbol "foo"))
     (define foo-2 (string->symbol "foo"))
     (define foo-3 (make-symbol "foo"))
     (define foo-4 (make-symbol "foo"))

     (eq? foo-1 foo-2)
     => #t
     ; Two interned symbols with the same name are the same object,

     (eq? foo-1 foo-3)
     => #f
     ; but a call to make-symbol with the same name returns a
     ; distinct object.

     (eq? foo-3 foo-4)
     => #f
     ; A call to make-symbol always returns a new object, even for
     ; the same name.

     foo-3
     => #<uninterned-symbol foo 8085290>
     ; Uninterned symbols print differently from interned symbols,

     (symbol? foo-3)
     => #t
     ; but they are still symbols,

     (symbol-interned? foo-3)
     => #f
     ; just not interned.


File: guile.info,  Node: Keywords,  Next: Other Types,  Prev: Symbols,  Up: Simple Data Types

5.5.8 Keywords
--------------

Keywords are self-evaluating objects with a convenient read syntax that
makes them easy to type.

   Guile's keyword support conforms to R5RS, and adds a (switchable)
read syntax extension to permit keywords to begin with `:' as well as
`#:', or to end with `:'.

* Menu:

* Why Use Keywords?::           Motivation for keyword usage.
* Coding With Keywords::        How to use keywords.
* Keyword Read Syntax::         Read syntax for keywords.
* Keyword Procedures::          Procedures for dealing with keywords.


File: guile.info,  Node: Why Use Keywords?,  Next: Coding With Keywords,  Up: Keywords

5.5.8.1 Why Use Keywords?
.........................

Keywords are useful in contexts where a program or procedure wants to be
able to accept a large number of optional arguments without making its
interface unmanageable.

   To illustrate this, consider a hypothetical `make-window' procedure,
which creates a new window on the screen for drawing into using some
graphical toolkit.  There are many parameters that the caller might
like to specify, but which could also be sensibly defaulted, for
example:

   * color depth - Default: the color depth for the screen

   * background color - Default: white

   * width - Default: 600

   * height - Default: 400

   If `make-window' did not use keywords, the caller would have to pass
in a value for each possible argument, remembering the correct argument
order and using a special value to indicate the default value for that
argument:

     (make-window 'default              ;; Color depth
                  'default              ;; Background color
                  800                   ;; Width
                  100                   ;; Height
                  ...)                  ;; More make-window arguments

   With keywords, on the other hand, defaulted arguments are omitted,
and non-default arguments are clearly tagged by the appropriate
keyword.  As a result, the invocation becomes much clearer:

     (make-window #:width 800 #:height 100)

   On the other hand, for a simpler procedure with few arguments, the
use of keywords would be a hindrance rather than a help.  The primitive
procedure `cons', for example, would not be improved if it had to be
invoked as

     (cons #:car x #:cdr y)

   So the decision whether to use keywords or not is purely pragmatic:
use them if they will clarify the procedure invocation at point of call.


File: guile.info,  Node: Coding With Keywords,  Next: Keyword Read Syntax,  Prev: Why Use Keywords?,  Up: Keywords

5.5.8.2 Coding With Keywords
............................

If a procedure wants to support keywords, it should take a rest argument
and then use whatever means is convenient to extract keywords and their
corresponding arguments from the contents of that rest argument.

   The following example illustrates the principle: the code for
`make-window' uses a helper procedure called `get-keyword-value' to
extract individual keyword arguments from the rest argument.

     (define (get-keyword-value args keyword default)
       (let ((kv (memq keyword args)))
         (if (and kv (>= (length kv) 2))
             (cadr kv)
             default)))

     (define (make-window . args)
       (let ((depth  (get-keyword-value args #:depth  screen-depth))
             (bg     (get-keyword-value args #:bg     "white"))
             (width  (get-keyword-value args #:width  800))
             (height (get-keyword-value args #:height 100))
             ...)
         ...))

   But you don't need to write `get-keyword-value'.  The `(ice-9
optargs)' module provides a set of powerful macros that you can use to
implement keyword-supporting procedures like this:

     (use-modules (ice-9 optargs))

     (define (make-window . args)
       (let-keywords args #f ((depth  screen-depth)
                              (bg     "white")
                              (width  800)
                              (height 100))
         ...))

Or, even more economically, like this:

     (use-modules (ice-9 optargs))

     (define* (make-window #:key (depth  screen-depth)
                                 (bg     "white")
                                 (width  800)
                                 (height 100))
       ...)

   For further details on `let-keywords', `define*' and other
facilities provided by the `(ice-9 optargs)' module, see *note Optional
Arguments::.


File: guile.info,  Node: Keyword Read Syntax,  Next: Keyword Procedures,  Prev: Coding With Keywords,  Up: Keywords

5.5.8.3 Keyword Read Syntax
...........................

Guile, by default, only recognizes a keyword syntax that is compatible
with R5RS.  A token of the form `#:NAME', where `NAME' has the same
syntax as a Scheme symbol (*note Symbol Read Syntax::), is the external
representation of the keyword named `NAME'.  Keyword objects print
using this syntax as well, so values containing keyword objects can be
read back into Guile.  When used in an expression, keywords are
self-quoting objects.

   If the `keyword' read option is set to `'prefix', Guile also
recognizes the alternative read syntax `:NAME'.  Otherwise, tokens of
the form `:NAME' are read as symbols, as required by R5RS.

   If the `keyword' read option is set to `'postfix', Guile recognizes
the SRFI-88 read syntax `NAME:' (*note SRFI-88::).  Otherwise, tokens
of this form are read as symbols.

   To enable and disable the alternative non-R5RS keyword syntax, you
use the `read-set!' procedure documented in *note User level options
interfaces:: and *note Reader options::.  Note that the `prefix' and
`postfix' syntax are mutually exclusive.

     (read-set! keywords 'prefix)

     #:type
     =>
     #:type

     :type
     =>
     #:type

     (read-set! keywords 'postfix)

     type:
     =>
     #:type

     :type
     =>
     :type

     (read-set! keywords #f)

     #:type
     =>
     #:type

     :type
     -|
     ERROR: In expression :type:
     ERROR: Unbound variable: :type
     ABORT: (unbound-variable)


File: guile.info,  Node: Keyword Procedures,  Prev: Keyword Read Syntax,  Up: Keywords

5.5.8.4 Keyword Procedures
..........................

 -- Scheme Procedure: keyword? obj
 -- C Function: scm_keyword_p (obj)
     Return `#t' if the argument OBJ is a keyword, else `#f'.

 -- Scheme Procedure: keyword->symbol keyword
 -- C Function: scm_keyword_to_symbol (keyword)
     Return the symbol with the same name as KEYWORD.

 -- Scheme Procedure: symbol->keyword symbol
 -- C Function: scm_symbol_to_keyword (symbol)
     Return the keyword with the same name as SYMBOL.

 -- C Function: int scm_is_keyword (SCM obj)
     Equivalent to `scm_is_true (scm_keyword_p (OBJ))'.

 -- C Function: SCM scm_from_locale_keyword (const char *str)
 -- C Function: SCM scm_from_locale_keywordn (const char *str, size_t
          len)
     Equivalent to `scm_symbol_to_keyword (scm_from_locale_symbol
     (STR))' and `scm_symbol_to_keyword (scm_from_locale_symboln (STR,
     LEN))', respectively.


File: guile.info,  Node: Other Types,  Prev: Keywords,  Up: Simple Data Types

5.5.9 "Functionality-Centric" Data Types
----------------------------------------

Procedures and macros are documented in their own chapter: see *note
Procedures and Macros::.

   Variable objects are documented as part of the description of Guile's
module system: see *note Variables::.

   Asyncs, dynamic roots and fluids are described in the chapter on
scheduling: see *note Scheduling::.

   Hooks are documented in the chapter on general utility functions: see
*note Hooks::.

   Ports are described in the chapter on I/O: see *note Input and
Output::.


File: guile.info,  Node: Compound Data Types,  Next: Smobs,  Prev: Simple Data Types,  Up: API Reference

5.6 Compound Data Types
=======================

This chapter describes Guile's compound data types.  By "compound" we
mean that the primary purpose of these data types is to act as
containers for other kinds of data (including other compound objects).
For instance, a (non-uniform) vector with length 5 is a container that
can hold five arbitrary Scheme objects.

   The various kinds of container object differ from each other in how
their memory is allocated, how they are indexed, and how particular
values can be looked up within them.

* Menu:

* Pairs::                       Scheme's basic building block.
* Lists::                       Special list functions supported by Guile.
* Vectors::                     One-dimensional arrays of Scheme objects.
* Uniform Numeric Vectors::     Vectors with elements of a single numeric type.
* Bit Vectors::                 Vectors of bits.
* Generalized Vectors::         Treating all vector-like things uniformly.
* Arrays::                      Matrices, etc.
* Records::
* Structures::
* Dictionary Types::            About dictionary types in general.
* Association Lists::           List-based dictionaries.
* Hash Tables::                 Table-based dictionaries.


File: guile.info,  Node: Pairs,  Next: Lists,  Up: Compound Data Types

5.6.1 Pairs
-----------

Pairs are used to combine two Scheme objects into one compound object.
Hence the name: A pair stores a pair of objects.

   The data type "pair" is extremely important in Scheme, just like in
any other Lisp dialect.  The reason is that pairs are not only used to
make two values available as one object, but that pairs are used for
constructing lists of values.  Because lists are so important in Scheme,
they are described in a section of their own (*note Lists::).

   Pairs can literally get entered in source code or at the REPL, in the
so-called "dotted list" syntax.  This syntax consists of an opening
parentheses, the first element of the pair, a dot, the second element
and a closing parentheses.  The following example shows how a pair
consisting of the two numbers 1 and 2, and a pair containing the symbols
`foo' and `bar' can be entered.  It is very important to write the
whitespace before and after the dot, because otherwise the Scheme
parser would not be able to figure out where to split the tokens.

     (1 . 2)
     (foo . bar)

   But beware, if you want to try out these examples, you have to
"quote" the expressions.  More information about quotation is available
in the section *note Expression Syntax::.  The correct way to try these
examples is as follows.

     '(1 . 2)
     =>
     (1 . 2)
     '(foo . bar)
     =>
     (foo . bar)

   A new pair is made by calling the procedure `cons' with two
arguments.  Then the argument values are stored into a newly allocated
pair, and the pair is returned.  The name `cons' stands for
"construct".  Use the procedure `pair?' to test whether a given Scheme
object is a pair or not.

 -- Scheme Procedure: cons x y
 -- C Function: scm_cons (x, y)
     Return a newly allocated pair whose car is X and whose cdr is Y.
     The pair is guaranteed to be different (in the sense of `eq?')
     from every previously existing object.

 -- Scheme Procedure: pair? x
 -- C Function: scm_pair_p (x)
     Return `#t' if X is a pair; otherwise return `#f'.

 -- C Function: int scm_is_pair (SCM x)
     Return 1 when X is a pair; otherwise return 0.

   The two parts of a pair are traditionally called "car" and "cdr".
They can be retrieved with procedures of the same name (`car' and
`cdr'), and can be modified with the procedures `set-car!' and
`set-cdr!'.  Since a very common operation in Scheme programs is to
access the car of a car of a pair, or the car of the cdr of a pair,
etc., the procedures called `caar', `cadr' and so on are also
predefined.

 -- Scheme Procedure: car pair
 -- Scheme Procedure: cdr pair
 -- C Function: scm_car (pair)
 -- C Function: scm_cdr (pair)
     Return the car or the cdr of PAIR, respectively.

 -- C Macro: SCM SCM_CAR (SCM pair)
 -- C Macro: SCM SCM_CDR (SCM pair)
     These two macros are the fastest way to access the car or cdr of a
     pair; they can be thought of as compiling into a single memory
     reference.

     These macros do no checking at all.  The argument PAIR must be a
     valid pair.

 -- Scheme Procedure: cddr pair
 -- Scheme Procedure: cdar pair
 -- Scheme Procedure: cadr pair
 -- Scheme Procedure: caar pair
 -- Scheme Procedure: cdddr pair
 -- Scheme Procedure: cddar pair
 -- Scheme Procedure: cdadr pair
 -- Scheme Procedure: cdaar pair
 -- Scheme Procedure: caddr pair
 -- Scheme Procedure: cadar pair
 -- Scheme Procedure: caadr pair
 -- Scheme Procedure: caaar pair
 -- Scheme Procedure: cddddr pair
 -- Scheme Procedure: cdddar pair
 -- Scheme Procedure: cddadr pair
 -- Scheme Procedure: cddaar pair
 -- Scheme Procedure: cdaddr pair
 -- Scheme Procedure: cdadar pair
 -- Scheme Procedure: cdaadr pair
 -- Scheme Procedure: cdaaar pair
 -- Scheme Procedure: cadddr pair
 -- Scheme Procedure: caddar pair
 -- Scheme Procedure: cadadr pair
 -- Scheme Procedure: cadaar pair
 -- Scheme Procedure: caaddr pair
 -- Scheme Procedure: caadar pair
 -- Scheme Procedure: caaadr pair
 -- Scheme Procedure: caaaar pair
 -- C Function: scm_cddr (pair)
 -- C Function: scm_cdar (pair)
 -- C Function: scm_cadr (pair)
 -- C Function: scm_caar (pair)
 -- C Function: scm_cdddr (pair)
 -- C Function: scm_cddar (pair)
 -- C Function: scm_cdadr (pair)
 -- C Function: scm_cdaar (pair)
 -- C Function: scm_caddr (pair)
 -- C Function: scm_cadar (pair)
 -- C Function: scm_caadr (pair)
 -- C Function: scm_caaar (pair)
 -- C Function: scm_cddddr (pair)
 -- C Function: scm_cdddar (pair)
 -- C Function: scm_cddadr (pair)
 -- C Function: scm_cddaar (pair)
 -- C Function: scm_cdaddr (pair)
 -- C Function: scm_cdadar (pair)
 -- C Function: scm_cdaadr (pair)
 -- C Function: scm_cdaaar (pair)
 -- C Function: scm_cadddr (pair)
 -- C Function: scm_caddar (pair)
 -- C Function: scm_cadadr (pair)
 -- C Function: scm_cadaar (pair)
 -- C Function: scm_caaddr (pair)
 -- C Function: scm_caadar (pair)
 -- C Function: scm_caaadr (pair)
 -- C Function: scm_caaaar (pair)
     These procedures are compositions of `car' and `cdr', where for
     example `caddr' could be defined by

          (define caddr (lambda (x) (car (cdr (cdr x)))))

     `cadr', `caddr' and `cadddr' pick out the second, third or fourth
     elements of a list, respectively.  SRFI-1 provides the same under
     the names `second', `third' and `fourth' (*note SRFI-1
     Selectors::).

 -- Scheme Procedure: set-car! pair value
 -- C Function: scm_set_car_x (pair, value)
     Stores VALUE in the car field of PAIR.  The value returned by
     `set-car!' is unspecified.

 -- Scheme Procedure: set-cdr! pair value
 -- C Function: scm_set_cdr_x (pair, value)
     Stores VALUE in the cdr field of PAIR.  The value returned by
     `set-cdr!' is unspecified.


File: guile.info,  Node: Lists,  Next: Vectors,  Prev: Pairs,  Up: Compound Data Types

5.6.2 Lists
-----------

A very important data type in Scheme--as well as in all other Lisp
dialects--is the data type "list".(1)

   This is the short definition of what a list is:

   * Either the empty list `()',

   * or a pair which has a list in its cdr.

* Menu:

* List Syntax::                 Writing literal lists.
* List Predicates::             Testing lists.
* List Constructors::           Creating new lists.
* List Selection::              Selecting from lists, getting their length.
* Append/Reverse::              Appending and reversing lists.
* List Modification::           Modifying existing lists.
* List Searching::              Searching for list elements
* List Mapping::                Applying procedures to lists.

   ---------- Footnotes ----------

   (1) Strictly speaking, Scheme does not have a real datatype "list".
Lists are made up of "chained pairs", and only exist by definition--a
list is a chain of pairs which looks like a list.


File: guile.info,  Node: List Syntax,  Next: List Predicates,  Up: Lists

5.6.2.1 List Read Syntax
........................

The syntax for lists is an opening parentheses, then all the elements of
the list (separated by whitespace) and finally a closing
parentheses.(1).

     (1 2 3)            ; a list of the numbers 1, 2 and 3
     ("foo" bar 3.1415) ; a string, a symbol and a real number
     ()                 ; the empty list

   The last example needs a bit more explanation.  A list with no
elements, called the "empty list", is special in some ways.  It is used
for terminating lists by storing it into the cdr of the last pair that
makes up a list.  An example will clear that up:

     (car '(1))
     =>
     1
     (cdr '(1))
     =>
     ()

   This example also shows that lists have to be quoted when written
(*note Expression Syntax::), because they would otherwise be
mistakingly taken as procedure applications (*note Simple Invocation::).

   ---------- Footnotes ----------

   (1) Note that there is no separation character between the list
elements, like a comma or a semicolon.


File: guile.info,  Node: List Predicates,  Next: List Constructors,  Prev: List Syntax,  Up: Lists

5.6.2.2 List Predicates
.......................

Often it is useful to test whether a given Scheme object is a list or
not.  List-processing procedures could use this information to test
whether their input is valid, or they could do different things
depending on the datatype of their arguments.

 -- Scheme Procedure: list? x
 -- C Function: scm_list_p (x)
     Return `#t' iff X is a proper list, else `#f'.

   The predicate `null?' is often used in list-processing code to tell
whether a given list has run out of elements.  That is, a loop somehow
deals with the elements of a list until the list satisfies `null?'.
Then, the algorithm terminates.

 -- Scheme Procedure: null? x
 -- C Function: scm_null_p (x)
     Return `#t' iff X is the empty list, else `#f'.

 -- C Function: int scm_is_null (SCM x)
     Return 1 when X is the empty list; otherwise return 0.


File: guile.info,  Node: List Constructors,  Next: List Selection,  Prev: List Predicates,  Up: Lists

5.6.2.3 List Constructors
.........................

This section describes the procedures for constructing new lists.
`list' simply returns a list where the elements are the arguments,
`cons*' is similar, but the last argument is stored in the cdr of the
last pair of the list.

 -- Scheme Procedure: list elem1 ... elemN
 -- C Function: scm_list_1 (elem1)
 -- C Function: scm_list_2 (elem1, elem2)
 -- C Function: scm_list_3 (elem1, elem2, elem3)
 -- C Function: scm_list_4 (elem1, elem2, elem3, elem4)
 -- C Function: scm_list_5 (elem1, elem2, elem3, elem4, elem5)
 -- C Function: scm_list_n (elem1, ..., elemN, SCM_UNDEFINED)
     Return a new list containing elements ELEM1 to ELEMN.

     `scm_list_n' takes a variable number of arguments, terminated by
     the special `SCM_UNDEFINED'.  That final `SCM_UNDEFINED' is not
     included in the list.  None of ELEM1 to ELEMN can themselves be
     `SCM_UNDEFINED', or `scm_list_n' will terminate at that point.

 -- Scheme Procedure: cons* arg1 arg2 ...
     Like `list', but the last arg provides the tail of the constructed
     list, returning `(cons ARG1 (cons ARG2 (cons ... ARGN)))'.
     Requires at least one argument.  If given one argument, that
     argument is returned as result.  This function is called `list*'
     in some other Schemes and in Common LISP.

 -- Scheme Procedure: list-copy lst
 -- C Function: scm_list_copy (lst)
     Return a (newly-created) copy of LST.

 -- Scheme Procedure: make-list n [init]
     Create a list containing of N elements, where each element is
     initialized to INIT.  INIT defaults to the empty list `()' if not
     given.

   Note that `list-copy' only makes a copy of the pairs which make up
the spine of the lists.  The list elements are not copied, which means
that modifying the elements of the new list also modifies the elements
of the old list.  On the other hand, applying procedures like
`set-cdr!' or `delv!' to the new list will not alter the old list.  If
you also need to copy the list elements (making a deep copy), use the
procedure `copy-tree' (*note Copying::).


File: guile.info,  Node: List Selection,  Next: Append/Reverse,  Prev: List Constructors,  Up: Lists

5.6.2.4 List Selection
......................

These procedures are used to get some information about a list, or to
retrieve one or more elements of a list.

 -- Scheme Procedure: length lst
 -- C Function: scm_length (lst)
     Return the number of elements in list LST.

 -- Scheme Procedure: last-pair lst
 -- C Function: scm_last_pair (lst)
     Return the last pair in LST, signalling an error if LST is
     circular.

 -- Scheme Procedure: list-ref list k
 -- C Function: scm_list_ref (list, k)
     Return the Kth element from LIST.

 -- Scheme Procedure: list-tail lst k
 -- Scheme Procedure: list-cdr-ref lst k
 -- C Function: scm_list_tail (lst, k)
     Return the "tail" of LST beginning with its Kth element.  The
     first element of the list is considered to be element 0.

     `list-tail' and `list-cdr-ref' are identical.  It may help to
     think of `list-cdr-ref' as accessing the Kth cdr of the list, or
     returning the results of cdring K times down LST.

 -- Scheme Procedure: list-head lst k
 -- C Function: scm_list_head (lst, k)
     Copy the first K elements from LST into a new list, and return it.


File: guile.info,  Node: Append/Reverse,  Next: List Modification,  Prev: List Selection,  Up: Lists

5.6.2.5 Append and Reverse
..........................

`append' and `append!' are used to concatenate two or more lists in
order to form a new list.  `reverse' and `reverse!' return lists with
the same elements as their arguments, but in reverse order.  The
procedure variants with an `!' directly modify the pairs which form the
list, whereas the other procedures create new pairs.  This is why you
should be careful when using the side-effecting variants.

 -- Scheme Procedure: append lst1 ... lstN
 -- Scheme Procedure: append! lst1 ... lstN
 -- C Function: scm_append (lstlst)
 -- C Function: scm_append_x (lstlst)
     Return a list comprising all the elements of lists LST1 to LSTN.

          (append '(x) '(y))          =>  (x y)
          (append '(a) '(b c d))      =>  (a b c d)
          (append '(a (b)) '((c)))    =>  (a (b) (c))

     The last argument LSTN may actually be any object; an improper
     list results if the last argument is not a proper list.

          (append '(a b) '(c . d))    =>  (a b c . d)
          (append '() 'a)             =>  a

     `append' doesn't modify the given lists, but the return may share
     structure with the final LSTN.  `append!' modifies the given lists
     to form its return.

     For `scm_append' and `scm_append_x', LSTLST is a list of the list
     operands LST1 ... LSTN.  That LSTLST itself is not modified or
     used in the return.

 -- Scheme Procedure: reverse lst
 -- Scheme Procedure: reverse! lst [newtail]
 -- C Function: scm_reverse (lst)
 -- C Function: scm_reverse_x (lst, newtail)
     Return a list comprising the elements of LST, in reverse order.

     `reverse' constructs a new list, `reverse!' modifies LST in
     constructing its return.

     For `reverse!', the optional NEWTAIL is appended to to the result.
     NEWTAIL isn't reversed, it simply becomes the list tail.  For
     `scm_reverse_x', the NEWTAIL parameter is mandatory, but can be
     `SCM_EOL' if no further tail is required.


File: guile.info,  Node: List Modification,  Next: List Searching,  Prev: Append/Reverse,  Up: Lists

5.6.2.6 List Modification
.........................

The following procedures modify an existing list, either by changing
elements of the list, or by changing the list structure itself.

 -- Scheme Procedure: list-set! list k val
 -- C Function: scm_list_set_x (list, k, val)
     Set the Kth element of LIST to VAL.

 -- Scheme Procedure: list-cdr-set! list k val
 -- C Function: scm_list_cdr_set_x (list, k, val)
     Set the Kth cdr of LIST to VAL.

 -- Scheme Procedure: delq item lst
 -- C Function: scm_delq (item, lst)
     Return a newly-created copy of LST with elements `eq?' to ITEM
     removed.  This procedure mirrors `memq': `delq' compares elements
     of LST against ITEM with `eq?'.

 -- Scheme Procedure: delv item lst
 -- C Function: scm_delv (item, lst)
     Return a newly-created copy of LST with elements `eqv?' to ITEM
     removed.  This procedure mirrors `memv': `delv' compares elements
     of LST against ITEM with `eqv?'.

 -- Scheme Procedure: delete item lst
 -- C Function: scm_delete (item, lst)
     Return a newly-created copy of LST with elements `equal?' to ITEM
     removed.  This procedure mirrors `member': `delete' compares
     elements of LST against ITEM with `equal?'.

     See also SRFI-1 which has an extended `delete' (*note SRFI-1
     Deleting::), and also an `lset-difference' which can delete
     multiple ITEMs in one call (*note SRFI-1 Set Operations::).

 -- Scheme Procedure: delq! item lst
 -- Scheme Procedure: delv! item lst
 -- Scheme Procedure: delete! item lst
 -- C Function: scm_delq_x (item, lst)
 -- C Function: scm_delv_x (item, lst)
 -- C Function: scm_delete_x (item, lst)
     These procedures are destructive versions of `delq', `delv' and
     `delete': they modify the pointers in the existing LST rather than
     creating a new list.  Caveat evaluator: Like other destructive
     list functions, these functions cannot modify the binding of LST,
     and so cannot be used to delete the first element of LST
     destructively.

 -- Scheme Procedure: delq1! item lst
 -- C Function: scm_delq1_x (item, lst)
     Like `delq!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eq?'.  See also `delv1!' and
     `delete1!'.

 -- Scheme Procedure: delv1! item lst
 -- C Function: scm_delv1_x (item, lst)
     Like `delv!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eqv?'.  See also `delq1!' and
     `delete1!'.

 -- Scheme Procedure: delete1! item lst
 -- C Function: scm_delete1_x (item, lst)
     Like `delete!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `equal?'.  See also `delq1!' and
     `delv1!'.

 -- Scheme Procedure: filter pred lst
 -- Scheme Procedure: filter! pred lst
     Return a list containing all elements from LST which satisfy the
     predicate PRED.  The elements in the result list have the same
     order as in LST.  The order in which PRED is applied to the list
     elements is not specified.

     `filter' does not change LST, but the result may share a tail with
     it.  `filter!' may modify LST to construct its return.


File: guile.info,  Node: List Searching,  Next: List Mapping,  Prev: List Modification,  Up: Lists

5.6.2.7 List Searching
......................

The following procedures search lists for particular elements.  They use
different comparison predicates for comparing list elements with the
object to be searched.  When they fail, they return `#f', otherwise
they return the sublist whose car is equal to the search object, where
equality depends on the equality predicate used.

 -- Scheme Procedure: memq x lst
 -- C Function: scm_memq (x, lst)
     Return the first sublist of LST whose car is `eq?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

 -- Scheme Procedure: memv x lst
 -- C Function: scm_memv (x, lst)
     Return the first sublist of LST whose car is `eqv?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

 -- Scheme Procedure: member x lst
 -- C Function: scm_member (x, lst)
     Return the first sublist of LST whose car is `equal?' to X where
     the sublists of LST are the non-empty lists returned by
     `(list-tail LST K)' for K less than the length of LST.  If X does
     not occur in LST, then `#f' (not the empty list) is returned.

     See also SRFI-1 which has an extended `member' function (*note
     SRFI-1 Searching::).


File: guile.info,  Node: List Mapping,  Prev: List Searching,  Up: Lists

5.6.2.8 List Mapping
....................

List processing is very convenient in Scheme because the process of
iterating over the elements of a list can be highly abstracted.  The
procedures in this section are the most basic iterating procedures for
lists.  They take a procedure and one or more lists as arguments, and
apply the procedure to each element of the list.  They differ in their
return value.

 -- Scheme Procedure: map proc arg1 arg2 ...
 -- Scheme Procedure: map-in-order proc arg1 arg2 ...
 -- C Function: scm_map (proc, arg1, args)
     Apply PROC to each element of the list ARG1 (if only two arguments
     are given), or to the corresponding elements of the argument lists
     (if more than two arguments are given).  The result(s) of the
     procedure applications are saved and returned in a list.  For
     `map', the order of procedure applications is not specified,
     `map-in-order' applies the procedure from left to right to the list
     elements.

 -- Scheme Procedure: for-each proc arg1 arg2 ...
     Like `map', but the procedure is always applied from left to right,
     and the result(s) of the procedure applications are thrown away.
     The return value is not specified.

   See also SRFI-1 which extends these functions to take lists of
unequal lengths (*note SRFI-1 Fold and Map::).


File: guile.info,  Node: Vectors,  Next: Uniform Numeric Vectors,  Prev: Lists,  Up: Compound Data Types

5.6.3 Vectors
-------------

Vectors are sequences of Scheme objects.  Unlike lists, the length of a
vector, once the vector is created, cannot be changed.  The advantage of
vectors over lists is that the time required to access one element of a
vector given its "position" (synonymous with "index"), a zero-origin
number, is constant, whereas lists have an access time linear to the
position of the accessed element in the list.

   Vectors can contain any kind of Scheme object; it is even possible to
have different types of objects in the same vector.  For vectors
containing vectors, you may wish to use arrays, instead.  Note, too,
that vectors are the special case of one dimensional non-uniform arrays
and that most array procedures operate happily on vectors (*note
Arrays::).

* Menu:

* Vector Syntax::               Read syntax for vectors.
* Vector Creation::             Dynamic vector creation and validation.
* Vector Accessors::            Accessing and modifying vector contents.
* Vector Accessing from C::     Ways to work with vectors from C.


File: guile.info,  Node: Vector Syntax,  Next: Vector Creation,  Up: Vectors

5.6.3.1 Read Syntax for Vectors
...............................

Vectors can literally be entered in source code, just like strings,
characters or some of the other data types.  The read syntax for vectors
is as follows: A sharp sign (`#'), followed by an opening parentheses,
all elements of the vector in their respective read syntax, and finally
a closing parentheses.  The following are examples of the read syntax
for vectors; where the first vector only contains numbers and the
second three different object types: a string, a symbol and a number in
hexadecimal notation.

     #(1 2 3)
     #("Hello" foo #xdeadbeef)

   Like lists, vectors have to be quoted:

     '#(a b c) => #(a b c)


File: guile.info,  Node: Vector Creation,  Next: Vector Accessors,  Prev: Vector Syntax,  Up: Vectors

5.6.3.2 Dynamic Vector Creation and Validation
..............................................

Instead of creating a vector implicitly by using the read syntax just
described, you can create a vector dynamically by calling one of the
`vector' and `list->vector' primitives with the list of Scheme values
that you want to place into a vector.  The size of the vector thus
created is determined implicitly by the number of arguments given.

 -- Scheme Procedure: vector . l
 -- Scheme Procedure: list->vector l
 -- C Function: scm_vector (l)
     Return a newly allocated vector composed of the given arguments.
     Analogous to `list'.

          (vector 'a 'b 'c) => #(a b c)

   The inverse operation is `vector->list':

 -- Scheme Procedure: vector->list v
 -- C Function: scm_vector_to_list (v)
     Return a newly allocated list composed of the elements of V.

          (vector->list '#(dah dah didah)) =>  (dah dah didah)
          (list->vector '(dididit dah)) =>  #(dididit dah)

   To allocate a vector with an explicitly specified size, use
`make-vector'.  With this primitive you can also specify an initial
value for the vector elements (the same value for all elements, that
is):

 -- Scheme Procedure: make-vector len [fill]
 -- C Function: scm_make_vector (len, fill)
     Return a newly allocated vector of LEN elements.  If a second
     argument is given, then each position is initialized to FILL.
     Otherwise the initial contents of each position is unspecified.

 -- C Function: SCM scm_c_make_vector (size_t k, SCM fill)
     Like `scm_make_vector', but the length is given as a `size_t'.

   To check whether an arbitrary Scheme value _is_ a vector, use the
`vector?' primitive:

 -- Scheme Procedure: vector? obj
 -- C Function: scm_vector_p (obj)
     Return `#t' if OBJ is a vector, otherwise return `#f'.

 -- C Function: int scm_is_vector (SCM obj)
     Return non-zero when OBJ is a vector, otherwise return `zero'.


File: guile.info,  Node: Vector Accessors,  Next: Vector Accessing from C,  Prev: Vector Creation,  Up: Vectors

5.6.3.3 Accessing and Modifying Vector Contents
...............................................

`vector-length' and `vector-ref' return information about a given
vector, respectively its size and the elements that are contained in
the vector.

 -- Scheme Procedure: vector-length vector
 -- C Function: scm_vector_length vector
     Return the number of elements in VECTOR as an exact integer.

 -- C Function: size_t scm_c_vector_length (SCM v)
     Return the number of elements in VECTOR as a `size_t'.

 -- Scheme Procedure: vector-ref vector k
 -- C Function: scm_vector_ref vector k
     Return the contents of position K of VECTOR.  K must be a valid
     index of VECTOR.
          (vector-ref '#(1 1 2 3 5 8 13 21) 5) => 8
          (vector-ref '#(1 1 2 3 5 8 13 21)
              (let ((i (round (* 2 (acos -1)))))
                (if (inexact? i)
                  (inexact->exact i)
                     i))) => 13

 -- C Function: SCM scm_c_vector_ref (SCM v, size_t k)
     Return the contents of position K (a `size_t') of VECTOR.

   A vector created by one of the dynamic vector constructor procedures
(*note Vector Creation::) can be modified using the following
procedures.

   _NOTE:_ According to R5RS, it is an error to use any of these
procedures on a literally read vector, because such vectors should be
considered as constants.  Currently, however, Guile does not detect this
error.

 -- Scheme Procedure: vector-set! vector k obj
 -- C Function: scm_vector_set_x vector k obj
     Store OBJ in position K of VECTOR.  K must be a valid index of
     VECTOR.  The value returned by `vector-set!' is unspecified.
          (let ((vec (vector 0 '(2 2 2 2) "Anna")))
            (vector-set! vec 1 '("Sue" "Sue"))
            vec) =>  #(0 ("Sue" "Sue") "Anna")

 -- C Function: void scm_c_vector_set_x (SCM v, size_t k, SCM obj)
     Store OBJ in position K (a `size_t') of V.

 -- Scheme Procedure: vector-fill! v fill
 -- C Function: scm_vector_fill_x (v, fill)
     Store FILL in every position of VECTOR.  The value returned by
     `vector-fill!' is unspecified.

 -- Scheme Procedure: vector-copy vec
 -- C Function: scm_vector_copy (vec)
     Return a copy of VEC.

 -- Scheme Procedure: vector-move-left! vec1 start1 end1 vec2 start2
 -- C Function: scm_vector_move_left_x (vec1, start1, end1, vec2,
          start2)
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-left!' copies elements in leftmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-left!' is usually appropriate when START1 is greater
     than START2.

 -- Scheme Procedure: vector-move-right! vec1 start1 end1 vec2 start2
 -- C Function: scm_vector_move_right_x (vec1, start1, end1, vec2,
          start2)
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-right!' copies elements in rightmost order.
     Therefore, in the case where VEC1 and VEC2 refer to the same
     vector, `vector-move-right!' is usually appropriate when START1 is
     less than START2.


File: guile.info,  Node: Vector Accessing from C,  Prev: Vector Accessors,  Up: Vectors

5.6.3.4 Vector Accessing from C
...............................

A vector can be read and modified from C with the functions
`scm_c_vector_ref' and `scm_c_vector_set_x', for example.  In addition
to these functions, there are two more ways to access vectors from C
that might be more efficient in certain situations: you can restrict
yourself to "simple vectors" and then use the very fast _simple vector
macros_; or you can use the very general framework for accessing all
kinds of arrays (*note Accessing Arrays from C::), which is more
verbose, but can deal efficiently with all kinds of vectors (and
arrays).  For vectors, you can use the `scm_vector_elements' and
`scm_vector_writable_elements' functions as shortcuts.

 -- C Function: int scm_is_simple_vector (SCM obj)
     Return non-zero if OBJ is a simple vector, else return zero.  A
     simple vector is a vector that can be used with the `SCM_SIMPLE_*'
     macros below.

     The following functions are guaranteed to return simple vectors:
     `scm_make_vector', `scm_c_make_vector', `scm_vector',
     `scm_list_to_vector'.

 -- C Macro: size_t SCM_SIMPLE_VECTOR_LENGTH (SCM vec)
     Evaluates to the length of the simple vector VEC.  No type
     checking is done.

 -- C Macro: SCM SCM_SIMPLE_VECTOR_REF (SCM vec, size_t idx)
     Evaluates to the element at position IDX in the simple vector VEC.
     No type or range checking is done.

 -- C Macro: void SCM_SIMPLE_VECTOR_SET (SCM vec, size_t idx, SCM val)
     Sets the element at position IDX in the simple vector VEC to VAL.
     No type or range checking is done.

 -- C Function: const SCM * scm_vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
     Acquirea handle for the vector VEC and return a pointer to the
     elements of it.  This pointer can only be used to read the
     elements of VEC.  When VEC is not a vector, an error is signaled.
     The handle mustr eventually be released with
     `scm_array_handle_release'.

     The variables pointed to by LENP and INCP are filled with the
     number of elements of the vector and the increment (number of
     elements) between successive elements, respectively.  Successive
     elements of VEC need not be contiguous in their underlying "root
     vector" returned here; hence the increment is not necessarily
     equal to 1 and may well be negative too (*note Shared Arrays::).

     The following example shows the typical way to use this function.
     It creates a list of all elements of VEC (in reverse order).

          scm_t_array_handle handle;
          size_t i, len;
          ssize_t inc;
          const SCM *elt;
          SCM list;

          elt = scm_vector_elements (vec, &handle, &len, &inc);
          list = SCM_EOL;
          for (i = 0; i < len; i++, elt += inc)
            list = scm_cons (*elt, list);
          scm_array_handle_release (&handle);


 -- C Function: SCM * scm_vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
     Like `scm_vector_elements' but the pointer can be used to modify
     the vector.

     The following example shows the typical way to use this function.
     It fills a vector with `#t'.

          scm_t_array_handle handle;
          size_t i, len;
          ssize_t inc;
          SCM *elt;

          elt = scm_vector_writable_elements (vec, &handle, &len, &inc);
          for (i = 0; i < len; i++, elt += inc)
            *elt = SCM_BOOL_T;
          scm_array_handle_release (&handle);



File: guile.info,  Node: Uniform Numeric Vectors,  Next: Bit Vectors,  Prev: Vectors,  Up: Compound Data Types

5.6.4 Uniform Numeric Vectors
-----------------------------

A uniform numeric vector is a vector whose elements are all of a single
numeric type.  Guile offers uniform numeric vectors for signed and
unsigned 8-bit, 16-bit, 32-bit, and 64-bit integers, two sizes of
floating point values, and complex floating-point numbers of these two
sizes.

   Strings could be regarded as uniform vectors of characters, *Note
Strings::.  Likewise, bit vectors could be regarded as uniform vectors
of bits, *Note Bit Vectors::.  Both are sufficiently different from
uniform numeric vectors that the procedures described here do not apply
to these two data types.  However, both strings and bit vectors are
generalized vectors, *Note Generalized Vectors::, and arrays, *Note
Arrays::.

   Uniform numeric vectors are the special case of one dimensional
uniform numeric arrays.

   Uniform numeric vectors can be useful since they consume less memory
than the non-uniform, general vectors.  Also, since the types they can
store correspond directly to C types, it is easier to work with them
efficiently on a low level.  Consider image processing as an example,
where you want to apply a filter to some image.  While you could store
the pixels of an image in a general vector and write a general
convolution function, things are much more efficient with uniform
vectors: the convolution function knows that all pixels are unsigned
8-bit values (say), and can use a very tight inner loop.

   That is, when it is written in C.  Functions for efficiently working
with uniform numeric vectors from C are listed at the end of this
section.

   Procedures similar to the vector procedures (*note Vectors::) are
provided for handling these uniform vectors, but they are distinct
datatypes and the two cannot be inter-mixed.  If you want to work
primarily with uniform numeric vectors, but want to offer support for
general vectors as a convenience, you can use one of the `scm_any_to_*'
functions.  They will coerce lists and vectors to the given type of
uniform vector.  Alternatively, you can write two versions of your
code: one that is fast and works only with uniform numeric vectors, and
one that works with any kind of vector but is slower.

   One set of the procedures listed below is a generic one: it works
with all types of uniform numeric vectors.  In addition to that, there
is a set of procedures for each type that only works with that type.
Unless you really need to the generality of the first set, it is best
to use the more specific functions.  They might not be that much
faster, but their use can serve as a kind of declaration and makes it
easier to optimize later on.

   The generic set of procedures uses `uniform' in its names, the
specific ones use the tag from the following table.

u8
     unsigned 8-bit integers

s8
     signed 8-bit integers

u16
     unsigned 16-bit integers

s16
     signed 16-bit integers

u32
     unsigned 32-bit integers

s32
     signed 32-bit integers

u64
     unsigned 64-bit integers

s64
     signed 64-bit integers

f32
     the C type `float'

f64
     the C type `double'

c32
     complex numbers in rectangular form with the real and imaginary
     part being a `float'

c64
     complex numbers in rectangular form with the real and imaginary
     part being a `double'


   The external representation (ie. read syntax) for these vectors is
similar to normal Scheme vectors, but with an additional tag from the
table above indiciating the vector's type.  For example,

     #u16(1 2 3)
     #f64(3.1415 2.71)

   Note that the read syntax for floating-point here conflicts with
`#f' for false.  In Standard Scheme one can write `(1 #f3)' for a three
element list `(1 #f 3)', but for Guile `(1 #f3)' is invalid.  `(1 #f
3)' is almost certainly what one should write anyway to make the
intention clear, so this is rarely a problem.

 -- Scheme Procedure: uniform-vector? obj
 -- Scheme Procedure: u8vector? obj
 -- Scheme Procedure: s8vector? obj
 -- Scheme Procedure: u16vector? obj
 -- Scheme Procedure: s16vector? obj
 -- Scheme Procedure: u32vector? obj
 -- Scheme Procedure: s32vector? obj
 -- Scheme Procedure: u64vector? obj
 -- Scheme Procedure: s64vector? obj
 -- Scheme Procedure: f32vector? obj
 -- Scheme Procedure: f64vector? obj
 -- Scheme Procedure: c32vector? obj
 -- Scheme Procedure: c64vector? obj
 -- C Function: scm_uniform_vector_p (obj)
 -- C Function: scm_u8vector_p (obj)
 -- C Function: scm_s8vector_p (obj)
 -- C Function: scm_u16vector_p (obj)
 -- C Function: scm_s16vector_p (obj)
 -- C Function: scm_u32vector_p (obj)
 -- C Function: scm_s32vector_p (obj)
 -- C Function: scm_u64vector_p (obj)
 -- C Function: scm_s64vector_p (obj)
 -- C Function: scm_f32vector_p (obj)
 -- C Function: scm_f64vector_p (obj)
 -- C Function: scm_c32vector_p (obj)
 -- C Function: scm_c64vector_p (obj)
     Return `#t' if OBJ is a homogeneous numeric vector of the
     indicated type.

 -- Scheme Procedure: make-u8vector n [value]
 -- Scheme Procedure: make-s8vector n [value]
 -- Scheme Procedure: make-u16vector n [value]
 -- Scheme Procedure: make-s16vector n [value]
 -- Scheme Procedure: make-u32vector n [value]
 -- Scheme Procedure: make-s32vector n [value]
 -- Scheme Procedure: make-u64vector n [value]
 -- Scheme Procedure: make-s64vector n [value]
 -- Scheme Procedure: make-f32vector n [value]
 -- Scheme Procedure: make-f64vector n [value]
 -- Scheme Procedure: make-c32vector n [value]
 -- Scheme Procedure: make-c64vector n [value]
 -- C Function: scm_make_u8vector n [value]
 -- C Function: scm_make_s8vector n [value]
 -- C Function: scm_make_u16vector n [value]
 -- C Function: scm_make_s16vector n [value]
 -- C Function: scm_make_u32vector n [value]
 -- C Function: scm_make_s32vector n [value]
 -- C Function: scm_make_u64vector n [value]
 -- C Function: scm_make_s64vector n [value]
 -- C Function: scm_make_f32vector n [value]
 -- C Function: scm_make_f64vector n [value]
 -- C Function: scm_make_c32vector n [value]
 -- C Function: scm_make_c64vector n [value]
     Return a newly allocated homogeneous numeric vector holding N
     elements of the indicated type.  If VALUE is given, the vector is
     initialized with that value, otherwise the contents are
     unspecified.

 -- Scheme Procedure: u8vector value ...
 -- Scheme Procedure: s8vector value ...
 -- Scheme Procedure: u16vector value ...
 -- Scheme Procedure: s16vector value ...
 -- Scheme Procedure: u32vector value ...
 -- Scheme Procedure: s32vector value ...
 -- Scheme Procedure: u64vector value ...
 -- Scheme Procedure: s64vector value ...
 -- Scheme Procedure: f32vector value ...
 -- Scheme Procedure: f64vector value ...
 -- Scheme Procedure: c32vector value ...
 -- Scheme Procedure: c64vector value ...
 -- C Function: scm_u8vector (values)
 -- C Function: scm_s8vector (values)
 -- C Function: scm_u16vector (values)
 -- C Function: scm_s16vector (values)
 -- C Function: scm_u32vector (values)
 -- C Function: scm_s32vector (values)
 -- C Function: scm_u64vector (values)
 -- C Function: scm_s64vector (values)
 -- C Function: scm_f32vector (values)
 -- C Function: scm_f64vector (values)
 -- C Function: scm_c32vector (values)
 -- C Function: scm_c64vector (values)
     Return a newly allocated homogeneous numeric vector of the
     indicated type, holding the given parameter VALUEs.  The vector
     length is the number of parameters given.

 -- Scheme Procedure: uniform-vector-length vec
 -- Scheme Procedure: u8vector-length vec
 -- Scheme Procedure: s8vector-length vec
 -- Scheme Procedure: u16vector-length vec
 -- Scheme Procedure: s16vector-length vec
 -- Scheme Procedure: u32vector-length vec
 -- Scheme Procedure: s32vector-length vec
 -- Scheme Procedure: u64vector-length vec
 -- Scheme Procedure: s64vector-length vec
 -- Scheme Procedure: f32vector-length vec
 -- Scheme Procedure: f64vector-length vec
 -- Scheme Procedure: c32vector-length vec
 -- Scheme Procedure: c64vector-length vec
 -- C Function: scm_uniform_vector_length (vec)
 -- C Function: scm_u8vector_length (vec)
 -- C Function: scm_s8vector_length (vec)
 -- C Function: scm_u16vector_length (vec)
 -- C Function: scm_s16vector_length (vec)
 -- C Function: scm_u32vector_length (vec)
 -- C Function: scm_s32vector_length (vec)
 -- C Function: scm_u64vector_length (vec)
 -- C Function: scm_s64vector_length (vec)
 -- C Function: scm_f32vector_length (vec)
 -- C Function: scm_f64vector_length (vec)
 -- C Function: scm_c32vector_length (vec)
 -- C Function: scm_c64vector_length (vec)
     Return the number of elements in VEC.

 -- Scheme Procedure: uniform-vector-ref vec i
 -- Scheme Procedure: u8vector-ref vec i
 -- Scheme Procedure: s8vector-ref vec i
 -- Scheme Procedure: u16vector-ref vec i
 -- Scheme Procedure: s16vector-ref vec i
 -- Scheme Procedure: u32vector-ref vec i
 -- Scheme Procedure: s32vector-ref vec i
 -- Scheme Procedure: u64vector-ref vec i
 -- Scheme Procedure: s64vector-ref vec i
 -- Scheme Procedure: f32vector-ref vec i
 -- Scheme Procedure: f64vector-ref vec i
 -- Scheme Procedure: c32vector-ref vec i
 -- Scheme Procedure: c64vector-ref vec i
 -- C Function: scm_uniform_vector_ref (vec i)
 -- C Function: scm_u8vector_ref (vec i)
 -- C Function: scm_s8vector_ref (vec i)
 -- C Function: scm_u16vector_ref (vec i)
 -- C Function: scm_s16vector_ref (vec i)
 -- C Function: scm_u32vector_ref (vec i)
 -- C Function: scm_s32vector_ref (vec i)
 -- C Function: scm_u64vector_ref (vec i)
 -- C Function: scm_s64vector_ref (vec i)
 -- C Function: scm_f32vector_ref (vec i)
 -- C Function: scm_f64vector_ref (vec i)
 -- C Function: scm_c32vector_ref (vec i)
 -- C Function: scm_c64vector_ref (vec i)
     Return the element at index I in VEC.  The first element in VEC is
     index 0.

 -- Scheme Procedure: uniform-vector-set! vec i value
 -- Scheme Procedure: u8vector-set! vec i value
 -- Scheme Procedure: s8vector-set! vec i value
 -- Scheme Procedure: u16vector-set! vec i value
 -- Scheme Procedure: s16vector-set! vec i value
 -- Scheme Procedure: u32vector-set! vec i value
 -- Scheme Procedure: s32vector-set! vec i value
 -- Scheme Procedure: u64vector-set! vec i value
 -- Scheme Procedure: s64vector-set! vec i value
 -- Scheme Procedure: f32vector-set! vec i value
 -- Scheme Procedure: f64vector-set! vec i value
 -- Scheme Procedure: c32vector-set! vec i value
 -- Scheme Procedure: c64vector-set! vec i value
 -- C Function: scm_uniform_vector_set_x (vec i value)
 -- C Function: scm_u8vector_set_x (vec i value)
 -- C Function: scm_s8vector_set_x (vec i value)
 -- C Function: scm_u16vector_set_x (vec i value)
 -- C Function: scm_s16vector_set_x (vec i value)
 -- C Function: scm_u32vector_set_x (vec i value)
 -- C Function: scm_s32vector_set_x (vec i value)
 -- C Function: scm_u64vector_set_x (vec i value)
 -- C Function: scm_s64vector_set_x (vec i value)
 -- C Function: scm_f32vector_set_x (vec i value)
 -- C Function: scm_f64vector_set_x (vec i value)
 -- C Function: scm_c32vector_set_x (vec i value)
 -- C Function: scm_c64vector_set_x (vec i value)
     Set the element at index I in VEC to VALUE.  The first element in
     VEC is index 0.  The return value is unspecified.

 -- Scheme Procedure: uniform-vector->list vec
 -- Scheme Procedure: u8vector->list vec
 -- Scheme Procedure: s8vector->list vec
 -- Scheme Procedure: u16vector->list vec
 -- Scheme Procedure: s16vector->list vec
 -- Scheme Procedure: u32vector->list vec
 -- Scheme Procedure: s32vector->list vec
 -- Scheme Procedure: u64vector->list vec
 -- Scheme Procedure: s64vector->list vec
 -- Scheme Procedure: f32vector->list vec
 -- Scheme Procedure: f64vector->list vec
 -- Scheme Procedure: c32vector->list vec
 -- Scheme Procedure: c64vector->list vec
 -- C Function: scm_uniform_vector_to_list (vec)
 -- C Function: scm_u8vector_to_list (vec)
 -- C Function: scm_s8vector_to_list (vec)
 -- C Function: scm_u16vector_to_list (vec)
 -- C Function: scm_s16vector_to_list (vec)
 -- C Function: scm_u32vector_to_list (vec)
 -- C Function: scm_s32vector_to_list (vec)
 -- C Function: scm_u64vector_to_list (vec)
 -- C Function: scm_s64vector_to_list (vec)
 -- C Function: scm_f32vector_to_list (vec)
 -- C Function: scm_f64vector_to_list (vec)
 -- C Function: scm_c32vector_to_list (vec)
 -- C Function: scm_c64vector_to_list (vec)
     Return a newly allocated list holding all elements of VEC.

 -- Scheme Procedure: list->u8vector lst
 -- Scheme Procedure: list->s8vector lst
 -- Scheme Procedure: list->u16vector lst
 -- Scheme Procedure: list->s16vector lst
 -- Scheme Procedure: list->u32vector lst
 -- Scheme Procedure: list->s32vector lst
 -- Scheme Procedure: list->u64vector lst
 -- Scheme Procedure: list->s64vector lst
 -- Scheme Procedure: list->f32vector lst
 -- Scheme Procedure: list->f64vector lst
 -- Scheme Procedure: list->c32vector lst
 -- Scheme Procedure: list->c64vector lst
 -- C Function: scm_list_to_u8vector (lst)
 -- C Function: scm_list_to_s8vector (lst)
 -- C Function: scm_list_to_u16vector (lst)
 -- C Function: scm_list_to_s16vector (lst)
 -- C Function: scm_list_to_u32vector (lst)
 -- C Function: scm_list_to_s32vector (lst)
 -- C Function: scm_list_to_u64vector (lst)
 -- C Function: scm_list_to_s64vector (lst)
 -- C Function: scm_list_to_f32vector (lst)
 -- C Function: scm_list_to_f64vector (lst)
 -- C Function: scm_list_to_c32vector (lst)
 -- C Function: scm_list_to_c64vector (lst)
     Return a newly allocated homogeneous numeric vector of the
     indicated type, initialized with the elements of the list LST.

 -- Scheme Procedure: any->u8vector obj
 -- Scheme Procedure: any->s8vector obj
 -- Scheme Procedure: any->u16vector obj
 -- Scheme Procedure: any->s16vector obj
 -- Scheme Procedure: any->u32vector obj
 -- Scheme Procedure: any->s32vector obj
 -- Scheme Procedure: any->u64vector obj
 -- Scheme Procedure: any->s64vector obj
 -- Scheme Procedure: any->f32vector obj
 -- Scheme Procedure: any->f64vector obj
 -- Scheme Procedure: any->c32vector obj
 -- Scheme Procedure: any->c64vector obj
 -- C Function: scm_any_to_u8vector (obj)
 -- C Function: scm_any_to_s8vector (obj)
 -- C Function: scm_any_to_u16vector (obj)
 -- C Function: scm_any_to_s16vector (obj)
 -- C Function: scm_any_to_u32vector (obj)
 -- C Function: scm_any_to_s32vector (obj)
 -- C Function: scm_any_to_u64vector (obj)
 -- C Function: scm_any_to_s64vector (obj)
 -- C Function: scm_any_to_f32vector (obj)
 -- C Function: scm_any_to_f64vector (obj)
 -- C Function: scm_any_to_c32vector (obj)
 -- C Function: scm_any_to_c64vector (obj)
     Return a (maybe newly allocated) uniform numeric vector of the
     indicated type, initialized with the elements of OBJ, which must
     be a list, a vector, or a uniform vector.  When OBJ is already a
     suitable uniform numeric vector, it is returned unchanged.

 -- C Function: int scm_is_uniform_vector (SCM uvec)
     Return non-zero when UVEC is a uniform numeric vector, zero
     otherwise.

 -- C Function: SCM scm_take_u8vector (const scm_t_uint8 *data, size_t
          len)
 -- C Function: SCM scm_take_s8vector (const scm_t_int8 *data, size_t
          len)
 -- C Function: SCM scm_take_u16vector (const scm_t_uint16 *data,
          size_t len)
 -- C Function: SCM scm_take_s168vector (const scm_t_int16 *data,
          size_t len)
 -- C Function: SCM scm_take_u32vector (const scm_t_uint32 *data,
          size_t len)
 -- C Function: SCM scm_take_s328vector (const scm_t_int32 *data,
          size_t len)
 -- C Function: SCM scm_take_u64vector (const scm_t_uint64 *data,
          size_t len)
 -- C Function: SCM scm_take_s64vector (const scm_t_int64 *data, size_t
          len)
 -- C Function: SCM scm_take_f32vector (const float *data, size_t len)
 -- C Function: SCM scm_take_f64vector (const double *data, size_t len)
 -- C Function: SCM scm_take_c32vector (const float *data, size_t len)
 -- C Function: SCM scm_take_c64vector (const double *data, size_t len)
     Return a new uniform numeric vector of the indicated type and
     length that uses the memory pointed to by DATA to store its
     elements.  This memory will eventually be freed with `free'.  The
     argument LEN specifies the number of elements in DATA, not its size
     in bytes.

     The `c32' and `c64' variants take a pointer to a C array of
     `float's or `double's.  The real parts of the complex numbers are
     at even indices in that array, the corresponding imaginary parts
     are at the following odd index.

 -- C Function: size_t scm_c_uniform_vector_length (SCM uvec)
     Return the number of elements of UVEC as a `size_t'.

 -- C Function: const void * scm_uniform_vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_uint8 * scm_u8vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_int8 * scm_s8vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_uint16 * scm_u16vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_int16 * scm_s16vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_uint32 * scm_u32vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_int32 * scm_s32vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_uint64 * scm_u64vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const scm_t_int64 * scm_s64vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const float * scm_f23vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const double * scm_f64vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const float * scm_c32vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: const double * scm_c64vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
     Like `scm_vector_elements' (*note Vector Accessing from C::), but
     returns a pointer to the elements of a uniform numeric vector of
     the indicated kind.

 -- C Function: void * scm_uniform_vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_uint8 * scm_u8vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_int8 * scm_s8vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_uint16 * scm_u16vector_writable_elements (SCM
          vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_int16 * scm_s16vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_uint32 * scm_u32vector_writable_elements (SCM
          vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_int32 * scm_s32vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_uint64 * scm_u64vector_writable_elements (SCM
          vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: scm_t_int64 * scm_s64vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: float * scm_f23vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: double * scm_f64vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: float * scm_c32vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
 -- C Function: double * scm_c64vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
     Like `scm_vector_writable_elements' (*note Vector Accessing from
     C::), but returns a pointer to the elements of a uniform numeric
     vector of the indicated kind.

 -- Scheme Procedure: uniform-vector-read! uvec [port_or_fd [start
          [end]]]
 -- C Function: scm_uniform_vector_read_x (uvec, port_or_fd, start, end)
     Fill the elements of UVEC by reading raw bytes from PORT-OR-FDES,
     using host byte order.

     The optional arguments START (inclusive) and END (exclusive) allow
     a specified region to be read, leaving the remainder of the vector
     unchanged.

     When PORT-OR-FDES is a port, all specified elements of UVEC are
     attempted to be read, potentially blocking while waiting formore
     input or end-of-file.  When PORT-OR-FD is an integer, a single
     call to read(2) is made.

     An error is signalled when the last element has only been
     partially filled before reaching end-of-file or in the single call
     to read(2).

     `uniform-vector-read!' returns the number of elements read.

     PORT-OR-FDES may be omitted, in which case it defaults to the
     value returned by `(current-input-port)'.

 -- Scheme Procedure: uniform-vector-write uvec [port_or_fd [start
          [end]]]
 -- C Function: scm_uniform_vector_write (uvec, port_or_fd, start, end)
     Write the elements of UVEC as raw bytes to PORT-OR-FDES, in the
     host byte order.

     The optional arguments START (inclusive) and END (exclusive) allow
     a specified region to be written.

     When PORT-OR-FDES is a port, all specified elements of UVEC are
     attempted to be written, potentially blocking while waiting for
     more room.  When PORT-OR-FD is an integer, a single call to
     write(2) is made.

     An error is signalled when the last element has only been
     partially written in the single call to write(2).

     The number of objects actually written is returned.  PORT-OR-FDES
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.


File: guile.info,  Node: Bit Vectors,  Next: Generalized Vectors,  Prev: Uniform Numeric Vectors,  Up: Compound Data Types

5.6.5 Bit Vectors
-----------------

Bit vectors are zero-origin, one-dimensional arrays of booleans.  They
are displayed as a sequence of `0's and `1's prefixed by `#*', e.g.,

     (make-bitvector 8 #f) =>
     #*00000000

   Bit vectors are are also generalized vectors, *Note Generalized
Vectors::, and can thus be used with the array procedures, *Note
Arrays::.  Bit vectors are the special case of one dimensional bit
arrays.

 -- Scheme Procedure: bitvector? obj
 -- C Function: scm_bitvector_p (obj)
     Return `#t' when OBJ is a bitvector, else return `#f'.

 -- C Function: int scm_is_bitvector (SCM obj)
     Return `1' when OBJ is a bitvector, else return `0'.

 -- Scheme Procedure: make-bitvector len [fill]
 -- C Function: scm_make_bitvector (len, fill)
     Create a new bitvector of length LEN and optionally initialize all
     elements to FILL.

 -- C Function: SCM scm_c_make_bitvector (size_t len, SCM fill)
     Like `scm_make_bitvector', but the length is given as a `size_t'.

 -- Scheme Procedure: bitvector . bits
 -- C Function: scm_bitvector (bits)
     Create a new bitvector with the arguments as elements.

 -- Scheme Procedure: bitvector-length vec
 -- C Function: scm_bitvector_length (vec)
     Return the length of the bitvector VEC.

 -- C Function: size_t scm_c_bitvector_length (SCM vec)
     Like `scm_bitvector_length', but the length is returned as a
     `size_t'.

 -- Scheme Procedure: bitvector-ref vec idx
 -- C Function: scm_bitvector_ref (vec, idx)
     Return the element at index IDX of the bitvector VEC.

 -- C Function: SCM scm_c_bitvector_ref (SCM obj, size_t idx)
     Return the element at index IDX of the bitvector VEC.

 -- Scheme Procedure: bitvector-set! vec idx val
 -- C Function: scm_bitvector_set_x (vec, idx, val)
     Set the element at index IDX of the bitvector VEC when VAL is
     true, else clear it.

 -- C Function: SCM scm_c_bitvector_set_x (SCM obj, size_t idx, SCM val)
     Set the element at index IDX of the bitvector VEC when VAL is
     true, else clear it.

 -- Scheme Procedure: bitvector-fill! vec val
 -- C Function: scm_bitvector_fill_x (vec, val)
     Set all elements of the bitvector VEC when VAL is true, else clear
     them.

 -- Scheme Procedure: list->bitvector list
 -- C Function: scm_list_to_bitvector (list)
     Return a new bitvector initialized with the elements of LIST.

 -- Scheme Procedure: bitvector->list vec
 -- C Function: scm_bitvector_to_list (vec)
     Return a new list initialized with the elements of the bitvector
     VEC.

 -- Scheme Procedure: bit-count bool bitvector
 -- C Function: scm_bit_count (bool, bitvector)
     Return a count of how many entries in BITVECTOR are equal to BOOL.
     For example,

          (bit-count #f #*000111000)  => 6

 -- Scheme Procedure: bit-position bool bitvector start
 -- C Function: scm_bit_position (bool, bitvector, start)
     Return the index of the first occurrance of BOOL in BITVECTOR,
     starting from START.  If there is no BOOL entry between START and
     the end of BITVECTOR, then return `#f'.  For example,

          (bit-position #t #*000101 0)  => 3
          (bit-position #f #*0001111 3) => #f

 -- Scheme Procedure: bit-invert! bitvector
 -- C Function: scm_bit_invert_x (bitvector)
     Modify BITVECTOR by replacing each element with its negation.

 -- Scheme Procedure: bit-set*! bitvector uvec bool
 -- C Function: scm_bit_set_star_x (bitvector, uvec, bool)
     Set entries of BITVECTOR to BOOL, with UVEC selecting the entries
     to change.  The return value is unspecified.

     If UVEC is a bit vector, then those entries where it has `#t' are
     the ones in BITVECTOR which are set to BOOL.  UVEC and BITVECTOR
     must be the same length.  When BOOL is `#t' it's like UVEC is
     OR'ed into BITVECTOR.  Or when BOOL is `#f' it can be seen as an
     ANDNOT.

          (define bv #*01000010)
          (bit-set*! bv #*10010001 #t)
          bv
          => #*11010011

     If UVEC is a uniform vector of unsigned long integers, then
     they're indexes into BITVECTOR which are set to BOOL.

          (define bv #*01000010)
          (bit-set*! bv #u(5 2 7) #t)
          bv
          => #*01100111

 -- Scheme Procedure: bit-count* bitvector uvec bool
 -- C Function: scm_bit_count_star (bitvector, uvec, bool)
     Return a count of how many entries in BITVECTOR are equal to BOOL,
     with UVEC selecting the entries to consider.

     UVEC is interpreted in the same way as for `bit-set*!' above.
     Namely, if UVEC is a bit vector then entries which have `#t' there
     are considered in BITVECTOR.  Or if UVEC is a uniform vector of
     unsigned long integers then it's the indexes in BITVECTOR to
     consider.

     For example,

          (bit-count* #*01110111 #*11001101 #t) => 3
          (bit-count* #*01110111 #u(7 0 4) #f)  => 2

 -- C Function: const scm_t_uint32 * scm_bitvector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *offp, size_t *lenp,
          ssize_t *incp)
     Like `scm_vector_elements' (*note Vector Accessing from C::), but
     for bitvectors.  The variable pointed to by OFFP is set to the
     value returned by `scm_array_handle_bit_elements_offset'.  See
     `scm_array_handle_bit_elements' for how to use the returned
     pointer and the offset.

 -- C Function: scm_t_uint32 * scm_bitvector_writable_elements (SCM
          vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp,
          ssize_t *incp)
     Like `scm_bitvector_elements', but the pointer is good for reading
     and writing.


File: guile.info,  Node: Generalized Vectors,  Next: Arrays,  Prev: Bit Vectors,  Up: Compound Data Types

5.6.6 Generalized Vectors
-------------------------

Guile has a number of data types that are generally vector-like:
strings, uniform numeric vectors, bitvectors, and of course ordinary
vectors of arbitrary Scheme values.  These types are disjoint: a Scheme
value belongs to at most one of the four types listed above.

   If you want to gloss over this distinction and want to treat all four
types with common code, you can use the procedures in this section.
They work with the _generalized vector_ type, which is the union of the
four vector-like types.

 -- Scheme Procedure: generalized-vector? obj
 -- C Function: scm_generalized_vector_p (obj)
     Return `#t' if OBJ is a vector, string, bitvector, or uniform
     numeric vector.

 -- Scheme Procedure: generalized-vector-length v
 -- C Function: scm_generalized_vector_length (v)
     Return the length of the generalized vector V.

 -- Scheme Procedure: generalized-vector-ref v idx
 -- C Function: scm_generalized_vector_ref (v, idx)
     Return the element at index IDX of the generalized vector V.

 -- Scheme Procedure: generalized-vector-set! v idx val
 -- C Function: scm_generalized_vector_set_x (v, idx, val)
     Set the element at index IDX of the generalized vector V to VAL.

 -- Scheme Procedure: generalized-vector->list v
 -- C Function: scm_generalized_vector_to_list (v)
     Return a new list whose elements are the elements of the
     generalized vector V.

 -- C Function: int scm_is_generalized_vector (SCM obj)
     Return `1' if OBJ is a vector, string, bitvector, or uniform
     numeric vector; else return `0'.

 -- C Function: size_t scm_c_generalized_vector_length (SCM v)
     Return the length of the generalized vector V.

 -- C Function: SCM scm_c_generalized_vector_ref (SCM v, size_t idx)
     Return the element at index IDX of the generalized vector V.

 -- C Function: void scm_c_generalized_vector_set_x (SCM v, size_t idx,
          SCM val)
     Set the element at index IDX of the generalized vector V to VAL.

 -- C Function: void scm_generalized_vector_get_handle (SCM v,
          scm_t_array_handle *handle)
     Like `scm_array_get_handle' but an error is signalled when V is
     not of rank one.  You can use `scm_array_handle_ref' and
     `scm_array_handle_set' to read and write the elements of V, or you
     can use functions like `scm_array_handle_<foo>_elements' to deal
     with specific types of vectors.


File: guile.info,  Node: Arrays,  Next: Records,  Prev: Generalized Vectors,  Up: Compound Data Types

5.6.7 Arrays
------------

"Arrays" are a collection of cells organized into an arbitrary number
of dimensions.  Each cell can be accessed in constant time by supplying
an index for each dimension.

   In the current implementation, an array uses a generalized vector for
the actual storage of its elements.  Any kind of generalized vector
will do, so you can have arrays of uniform numeric values, arrays of
characters, arrays of bits, and of course, arrays of arbitrary Scheme
values.  For example, arrays with an underlying `c64vector' might be
nice for digital signal processing, while arrays made from a `u8vector'
might be used to hold gray-scale images.

   The number of dimensions of an array is called its "rank".  Thus, a
matrix is an array of rank 2, while a vector has rank 1.  When
accessing an array element, you have to specify one exact integer for
each dimension.  These integers are called the "indices" of the
element.  An array specifies the allowed range of indices for each
dimension via an inclusive lower and upper bound.  These bounds can
well be negative, but the upper bound must be greater than or equal to
the lower bound minus one.  When all lower bounds of an array are zero,
it is called a "zero-origin" array.

   Arrays can be of rank 0, which could be interpreted as a scalar.
Thus, a zero-rank array can store exactly one object and the list of
indices of this element is the empty list.

   Arrays contain zero elements when one of their dimensions has a zero
length.  These empty arrays maintain information about their shape: a
matrix with zero columns and 3 rows is different from a matrix with 3
columns and zero rows, which again is different from a vector of length
zero.

   Generalized vectors, such as strings, uniform numeric vectors, bit
vectors and ordinary vectors, are the special case of one dimensional
arrays.

* Menu:

* Array Syntax::
* Array Procedures::
* Shared Arrays::
* Accessing Arrays from C::


File: guile.info,  Node: Array Syntax,  Next: Array Procedures,  Up: Arrays

5.6.7.1 Array Syntax
....................

An array is displayed as `#' followed by its rank, followed by a tag
that describes the underlying vector, optionally followed by
information about its shape, and finally followed by the cells,
organized into dimensions using parentheses.

   In more words, the array tag is of the form

       #<rank><vectag><@lower><:len><@lower><:len>...

   where `<rank>' is a positive integer in decimal giving the rank of
the array.  It is omitted when the rank is 1 and the array is non-shared
and has zero-origin (see below).  For shared arrays and for a non-zero
origin, the rank is always printed even when it is 1 to dinstinguish
them from ordinary vectors.

   The `<vectag>' part is the tag for a uniform numeric vector, like
`u8', `s16', etc, `b' for bitvectors, or `a' for strings.  It is empty
for ordinary vectors.

   The `<@lower>' part is a `@' character followed by a signed integer
in decimal giving the lower bound of a dimension.  There is one
`<@lower>' for each dimension.  When all lower bounds are zero, all
`<@lower>' parts are omitted.

   The `<:len>' part is a `:' character followed by an unsigned integer
in decimal giving the length of a dimension.  Like for the lower
bounds, there is one `<:len>' for each dimension, and the `<:len>' part
always follows the `<@lower>' part for a dimension.  Lengths are only
then printed when they can't be deduced from the nested lists of
elements of the array literal, which can happen when at least one
length is zero.

   As a special case, an array of rank 0 is printed as
`#0<vectag>(<scalar>)', where `<scalar>' is the result of printing the
single element of the array.

   Thus,

`#(1 2 3)'
     is an ordinary array of rank 1 with lower bound 0 in dimension 0.
     (I.e., a regular vector.)

`#@2(1 2 3)'
     is an ordinary array of rank 1 with lower bound 2 in dimension 0.

`#2((1 2 3) (4 5 6))'
     is a non-uniform array of rank 2; a 3x3 matrix with index ranges
     0..2 and 0..2.

`#u32(0 1 2)'
     is a uniform u8 array of rank 1.

`#2u32@2@3((1 2) (2 3))'
     is a uniform u8 array of rank 2 with index ranges 2..3 and 3..4.

`#2()'
     is a two-dimensional array with index ranges 0..-1 and 0..-1, i.e.
     both dimensions have length zero.

`#2:0:2()'
     is a two-dimensional array with index ranges 0..-1 and 0..1, i.e.
     the first dimension has length zero, but the second has length 2.

`#0(12)'
     is a rank-zero array with contents 12.



File: guile.info,  Node: Array Procedures,  Next: Shared Arrays,  Prev: Array Syntax,  Up: Arrays

5.6.7.2 Array Procedures
........................

When an array is created, the range of each dimension must be
specified, e.g., to create a 2x3 array with a zero-based index:

     (make-array 'ho 2 3) => #2((ho ho ho) (ho ho ho))

   The range of each dimension can also be given explicitly, e.g.,
another way to create the same array:

     (make-array 'ho '(0 1) '(0 2)) => #2((ho ho ho) (ho ho ho))

   The following procedures can be used with arrays (or vectors).  An
argument shown as IDX... means one parameter for each dimension in the
array.  A IDXLIST argument means a list of such values, one for each
dimension.

 -- Scheme Procedure: array? obj
 -- C Function: scm_array_p (obj, unused)
     Return `#t' if the OBJ is an array, and `#f' if not.

     The second argument to scm_array_p is there for historical reasons,
     but it is not used.  You should always pass `SCM_UNDEFINED' as its
     value.

 -- Scheme Procedure: typed-array? obj type
 -- C Function: scm_typed_array_p (obj, type)
     Return `#t' if the OBJ is an array of type TYPE, and `#f' if not.

 -- C Function: int scm_is_array (SCM obj)
     Return `1' if the OBJ is an array and `0' if not.

 -- C Function: int scm_is_typed_array (SCM obj, SCM type)
     Return `0' if the OBJ is an array of type TYPE, and `1' if not.

 -- Scheme Procedure: make-array fill bound ...
 -- C Function: scm_make_array (fill, bounds)
     Equivalent to `(make-typed-array #t FILL BOUND ...)'.

 -- Scheme Procedure: make-typed-array type fill bound ...
 -- C Function: scm_make_typed_array (type, fill, bounds)
     Create and return an array that has as many dimensions as there are
     BOUNDs and (maybe) fill it with FILL.

     The underlaying storage vector is created according to TYPE, which
     must be a symbol whose name is the `vectag' of the array as
     explained above, or `#t' for ordinary, non-specialized arrays.

     For example, using the symbol `f64' for TYPE will create an array
     that uses a `f64vector' for storing its elements, and `a' will use
     a string.

     When FILL is not the special _unspecified_ value, the new array is
     filled with FILL.  Otherwise, the initial contents of the array is
     unspecified.  The special _unspecified_ value is stored in the
     variable `*unspecified*' so that for example `(make-typed-array
     'u32 *unspecified* 4)' creates a uninitialized `u32' vector of
     length 4.

     Each BOUND may be a positive non-zero integer N, in which case the
     index for that dimension can range from 0 through N-1; or an
     explicit index range specifier in the form `(LOWER UPPER)', where
     both LOWER and UPPER are integers, possibly less than zero, and
     possibly the same number (however, LOWER cannot be greater than
     UPPER).

 -- Scheme Procedure: list->array dimspec list
     Equivalent to `(list->typed-array #t DIMSPEC LIST)'.

 -- Scheme Procedure: list->typed-array type dimspec list
 -- C Function: scm_list_to_typed_array (type, dimspec, list)
     Return an array of the type indicated by TYPE with elements the
     same as those of LIST.

     The argument DIMSPEC determines the number of dimensions of the
     array and their lower bounds.  When DIMSPEC is an exact integer,
     it gives the number of dimensions directly and all lower bounds are
     zero.  When it is a list of exact integers, then each element is
     the lower index bound of a dimension, and there will be as many
     dimensions as elements in the list.

 -- Scheme Procedure: array-type array
     Return the type of ARRAY.  This is the `vectag' used for printing
     ARRAY (or `#t' for ordinary arrays) and can be used with
     `make-typed-array' to create an array of the same kind as ARRAY.

 -- Scheme Procedure: array-ref array idx ...
     Return the element at `(idx ...)' in ARRAY.

          (define a (make-array 999 '(1 2) '(3 4)))
          (array-ref a 2 4) => 999

 -- Scheme Procedure: array-in-bounds? array idx ...
 -- C Function: scm_array_in_bounds_p (array, idxlist)
     Return `#t' if the given index would be acceptable to `array-ref'.

          (define a (make-array #f '(1 2) '(3 4)))
          (array-in-bounds? a 2 3) => #t
          (array-in-bounds? a 0 0) => #f

 -- Scheme Procedure: array-set! array obj idx ...
 -- C Function: scm_array_set_x (array, obj, idxlist)
     Set the element at `(idx ...)' in ARRAY to OBJ.  The return value
     is unspecified.

          (define a (make-array #f '(0 1) '(0 1)))
          (array-set! a #t 1 1)
          a => #2((#f #f) (#f #t))

 -- Scheme Procedure: enclose-array array dim1 ...
 -- C Function: scm_enclose_array (array, dimlist)
     DIM1, DIM2 ... should be nonnegative integers less than the rank
     of ARRAY.  `enclose-array' returns an array resembling an array of
     shared arrays.  The dimensions of each shared array are the same
     as the DIMth dimensions of the original array, the dimensions of
     the outer array are the same as those of the original array that
     did not match a DIM.

     An enclosed array is not a general Scheme array.  Its elements may
     not be set using `array-set!'.  Two references to the same element
     of an enclosed array will be `equal?' but will not in general be
     `eq?'.  The value returned by `array-prototype' when given an
     enclosed array is unspecified.

     For example,

          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1)
          =>
          #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

          (enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0)
          =>
          #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>

 -- Scheme Procedure: array-shape array
 -- Scheme Procedure: array-dimensions array
 -- C Function: scm_array_dimensions (array)
     Return a list of the bounds for each dimenson of ARRAY.

     `array-shape' gives `(LOWER UPPER)' for each dimension.
     `array-dimensions' instead returns just UPPER+1 for dimensions
     with a 0 lower bound.  Both are suitable as input to `make-array'.

     For example,

          (define a (make-array 'foo '(-1 3) 5))
          (array-shape a)      => ((-1 3) (0 4))
          (array-dimensions a) => ((-1 3) 5)

 -- Scheme Procedure: array-rank obj
 -- C Function: scm_array_rank (obj)
     Return the rank of ARRAY.

 -- C Function: size_t scm_c_array_rank (SCM array)
     Return the rank of ARRAY as a `size_t'.

 -- Scheme Procedure: array->list array
 -- C Function: scm_array_to_list (array)
     Return a list consisting of all the elements, in order, of ARRAY.

 -- Scheme Procedure: array-copy! src dst
 -- Scheme Procedure: array-copy-in-order! src dst
 -- C Function: scm_array_copy_x (src, dst)
     Copy every element from vector or array SRC to the corresponding
     element of DST.  DST must have the same rank as SRC, and be at
     least as large in each dimension.  The return value is unspecified.

 -- Scheme Procedure: array-fill! array fill
 -- C Function: scm_array_fill_x (array, fill)
     Store FILL in every element of ARRAY.  The value returned is
     unspecified.

 -- Scheme Procedure: array-equal? array1 array2 ...
     Return `#t' if all arguments are arrays with the same shape, the
     same type, and have corresponding elements which are either
     `equal?' or `array-equal?'.  This function differs from `equal?'
     (*note Equality::) in that a one dimensional shared array may be
     `array-equal?' but not `equal?' to a vector or uniform vector.

 -- Scheme Procedure: array-map! dst proc src1 ... srcN
 -- Scheme Procedure: array-map-in-order! dst proc src1 ... srcN
 -- C Function: scm_array_map_x (dst, proc, srclist)
     Set each element of the DST array to values obtained from calls to
     PROC.  The value returned is unspecified.

     Each call is `(PROC ELEM1 ... ELEMN)', where each ELEM is from the
     corresponding SRC array, at the DST index.  `array-map-in-order!'
     makes the calls in row-major order, `array-map!' makes them in an
     unspecified order.

     The SRC arrays must have the same number of dimensions as DST, and
     must have a range for each dimension which covers the range in
     DST.  This ensures all DST indices are valid in each SRC.

 -- Scheme Procedure: array-for-each proc src1 ... srcN
 -- C Function: scm_array_for_each (proc, src1, srclist)
     Apply PROC to each tuple of elements of SRC1 ...  SRCN, in
     row-major order.  The value returned is unspecified.

 -- Scheme Procedure: array-index-map! dst proc
 -- C Function: scm_array_index_map_x (dst, proc)
     Set each element of the DST array to values returned by calls to
     PROC.  The value returned is unspecified.

     Each call is `(PROC I1 ... IN)', where I1...IN is the destination
     index, one parameter for each dimension.  The order in which the
     calls are made is unspecified.

     For example, to create a 4x4 matrix representing a cyclic group,

              / 0 1 2 3 \
              | 1 2 3 0 |
              | 2 3 0 1 |
              \ 3 0 1 2 /

          (define a (make-array #f 4 4))
          (array-index-map! a (lambda (i j)
                                (modulo (+ i j) 4)))

 -- Scheme Procedure: uniform-array-read! ra [port_or_fd [start [end]]]
 -- C Function: scm_uniform_array_read_x (ra, port_or_fd, start, end)
     Attempt to read all elements of URA, in lexicographic order, as
     binary objects from PORT-OR-FDES.  If an end of file is
     encountered, the objects up to that point are put into URA
     (starting at the beginning) and the remainder of the array is
     unchanged.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be read, leaving the remainder of
     the vector unchanged.

     `uniform-array-read!' returns the number of objects read.
     PORT-OR-FDES may be omitted, in which case it defaults to the value
     returned by `(current-input-port)'.

 -- Scheme Procedure: uniform-array-write v [port_or_fd [start [end]]]
 -- C Function: scm_uniform_array_write (v, port_or_fd, start, end)
     Writes all elements of URA as binary objects to PORT-OR-FDES.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be written.

     The number of objects actually written is returned.  PORT-OR-FDES
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.


File: guile.info,  Node: Shared Arrays,  Next: Accessing Arrays from C,  Prev: Array Procedures,  Up: Arrays

5.6.7.3 Shared Arrays
.....................

 -- Scheme Procedure: make-shared-array oldarray mapfunc bound ...
 -- C Function: scm_make_shared_array (oldarray, mapfunc, boundlist)
     Return a new array which shares the storage of OLDARRAY.  Changes
     made through either affect the same underlying storage.  The
     BOUND... arguments are the shape of the new array, the same as
     `make-array' (*note Array Procedures::).

     MAPFUNC translates coordinates from the new array to the OLDARRAY.
     It's called as `(MAPFUNC newidx1 ...)' with one parameter for each
     dimension of the new array, and should return a list of indices
     for OLDARRAY, one for each dimension of OLDARRAY.

     MAPFUNC must be affine linear, meaning that each OLDARRAY index
     must be formed by adding integer multiples (possibly negative) of
     some or all of NEWIDX1 etc, plus a possible integer offset.  The
     multiples and offset must be the same in each call.


     One good use for a shared array is to restrict the range of some
     dimensions, so as to apply say `array-for-each' or `array-fill!'
     to only part of an array.  The plain `list' function can be used
     for MAPFUNC in this case, making no changes to the index values.
     For example,

          (make-shared-array #2((a b c) (d e f) (g h i)) list 3 2)
          => #2((a b) (d e) (g h))

     The new array can have fewer dimensions than OLDARRAY, for example
     to take a column from an array.

          (make-shared-array #2((a b c) (d e f) (g h i))
                             (lambda (i) (list i 2))
                             '(0 2))
          => #1(c f i)

     A diagonal can be taken by using the single new array index for
     both row and column in the old array.  For example,

          (make-shared-array #2((a b c) (d e f) (g h i))
                             (lambda (i) (list i i))
                             '(0 2))
          => #1(a e i)

     Dimensions can be increased by for instance considering portions
     of a one dimensional array as rows in a two dimensional array.
     (`array-contents' below can do the opposite, flattening an array.)

          (make-shared-array #1(a b c d e f g h i j k l)
                             (lambda (i j) (list (+ (* i 3) j)))
                             4 3)
          => #2((a b c) (d e f) (g h i) (j k l))

     By negating an index the order that elements appear can be
     reversed.  The following just reverses the column order,

          (make-shared-array #2((a b c) (d e f) (g h i))
                             (lambda (i j) (list i (- 2 j)))
                             3 3)
          => #2((c b a) (f e d) (i h g))

     A fixed offset on indexes allows for instance a change from a 0
     based to a 1 based array,

          (define x #2((a b c) (d e f) (g h i)))
          (define y (make-shared-array x
                                       (lambda (i j) (list (1- i) (1- j)))
                                       '(1 3) '(1 3)))
          (array-ref x 0 0) => a
          (array-ref y 1 1) => a

     A multiple on an index allows every Nth element of an array to be
     taken.  The following is every third element,

          (make-shared-array #1(a b c d e f g h i j k l)
                             (lambda (i) (list (* i 3)))
                             4)
          => #1(a d g j)

     The above examples can be combined to make weird and wonderful
     selections from an array, but it's important to note that because
     MAPFUNC must be affine linear, arbitrary permutations are not
     possible.

     In the current implementation, MAPFUNC is not called for every
     access to the new array but only on some sample points to
     establish a base and stride for new array indices in OLDARRAY
     data.  A few sample points are enough because MAPFUNC is linear.

 -- Scheme Procedure: shared-array-increments array
 -- C Function: scm_shared_array_increments (array)
     For each dimension, return the distance between elements in the
     root vector.

 -- Scheme Procedure: shared-array-offset array
 -- C Function: scm_shared_array_offset (array)
     Return the root vector index of the first element in the array.

 -- Scheme Procedure: shared-array-root array
 -- C Function: scm_shared_array_root (array)
     Return the root vector of a shared array.

 -- Scheme Procedure: array-contents array [strict]
 -- C Function: scm_array_contents (array, strict)
     If ARRAY may be "unrolled" into a one dimensional shared array
     without changing their order (last subscript changing fastest),
     then `array-contents' returns that shared array, otherwise it
     returns `#f'.  All arrays made by `make-array' and
     `make-typed-array' may be unrolled, some arrays made by
     `make-shared-array' may not be.

     If the optional argument STRICT is provided, a shared array will
     be returned only if its elements are stored internally contiguous
     in memory.

 -- Scheme Procedure: transpose-array array dim1 ...
 -- C Function: scm_transpose_array (array, dimlist)
     Return an array sharing contents with ARRAY, but with dimensions
     arranged in a different order.  There must be one DIM argument for
     each dimension of ARRAY.  DIM1, DIM2, ... should be integers
     between 0 and the rank of the array to be returned.  Each integer
     in that range must appear at least once in the argument list.

     The values of DIM1, DIM2, ... correspond to dimensions in the
     array to be returned, and their positions in the argument list to
     dimensions of ARRAY.  Several DIMs may have the same value, in
     which case the returned array will have smaller rank than ARRAY.

          (transpose-array '#2((a b) (c d)) 1 0) => #2((a c) (b d))
          (transpose-array '#2((a b) (c d)) 0 0) => #1(a d)
          (transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) =>
                          #2((a 4) (b 5) (c 6))


File: guile.info,  Node: Accessing Arrays from C,  Prev: Shared Arrays,  Up: Arrays

5.6.7.4 Accessing Arrays from C
...............................

Arrays, especially uniform numeric arrays, are useful to efficiently
represent large amounts of rectangularily organized information, such as
matrices, images, or generally blobs of binary data.  It is desirable to
access these blobs in a C like manner so that they can be handed to
external C code such as linear algebra libraries or image processing
routines.

   While pointers to the elements of an array are in use, the array
itself must be protected so that the pointer remains valid.  Such a
protected array is said to be "reserved".  A reserved array can be read
but modifications to it that would cause the pointer to its elements to
become invalid are prevented.  When you attempt such a modification, an
error is signalled.

   (This is similar to locking the array while it is in use, but without
the danger of a deadlock.  In a multi-threaded program, you will need
additional synchronization to avoid modifying reserved arrays.)

   You must take care to always unreserve an array after reserving it,
even in the presence of non-local exits.  If a non-local exit can
happen between these two calls, you should install a dynwind context
that releases the array when it is left (*note Dynamic Wind::).

   In addition, array reserving and unreserving must be properly
paired.  For instance, when reserving two or more arrays in a certain
order, you need to unreserve them in the opposite order.

   Once you have reserved an array and have retrieved the pointer to its
elements, you must figure out the layout of the elements in memory.
Guile allows slices to be taken out of arrays without actually making a
copy, such as making an alias for the diagonal of a matrix that can be
treated as a vector.  Arrays that result from such an operation are not
stored contiguously in memory and when working with their elements
directly, you need to take this into account.

   The layout of array elements in memory can be defined via a _mapping
function_ that computes a scalar position from a vector of indices.
The scalar position then is the offset of the element with the given
indices from the start of the storage block of the array.

   In Guile, this mapping function is restricted to be "affine": all
mapping functions of Guile arrays can be written as `p = b + c[0]*i[0]
+ c[1]*i[1] + ... + c[n-1]*i[n-1]' where `i[k]' is the kth index and
`n' is the rank of the array.  For example, a matrix of size 3x3 would
have `b == 0', `c[0] == 3' and `c[1] == 1'.  When you transpose this
matrix (with `transpose-array', say), you will get an array whose
mapping function has `b == 0', `c[0] == 1' and `c[1] == 3'.

   The function `scm_array_handle_dims' gives you (indirect) access to
the coefficients `c[k]'.

   Note that there are no functions for accessing the elements of a
character array yet.  Once the string implementation of Guile has been
changed to use Unicode, we will provide them.

 -- C Type: scm_t_array_handle
     This is a structure type that holds all information necessary to
     manage the reservation of arrays as explained above.  Structures
     of this type must be allocated on the stack and must only be
     accessed by the functions listed below.

 -- C Function: void scm_array_get_handle (SCM array,
          scm_t_array_handle *handle)
     Reserve ARRAY, which must be an array, and prepare HANDLE to be
     used with the functions below.  You must eventually call
     `scm_array_handle_release' on HANDLE, and do this in a properly
     nested fashion, as explained above.  The structure pointed to by
     HANDLE does not need to be initialized before calling this
     function.

 -- C Function: void scm_array_handle_release (scm_t_array_handle
          *handle)
     End the array reservation represented by HANDLE.  After a call to
     this function, HANDLE might be used for another reservation.

 -- C Function: size_t scm_array_handle_rank (scm_t_array_handle
          *handle)
     Return the rank of the array represented by HANDLE.

 -- C Type: scm_t_array_dim
     This structure type holds information about the layout of one
     dimension of an array.  It includes the following fields:

    `ssize_t lbnd'
    `ssize_t ubnd'
          The lower and upper bounds (both inclusive) of the
          permissible index range for the given dimension.  Both values
          can be negative, but LBND is always less than or equal to
          UBND.

    `ssize_t inc'
          The distance from one element of this dimension to the next.
          Note, too, that this can be negative.

 -- C Function: const scm_t_array_dim * scm_array_handle_dims
          (scm_t_array_handle *handle)
     Return a pointer to a C vector of information about the dimensions
     of the array represented by HANDLE.  This pointer is valid as long
     as the array remains reserved.  As explained above, the
     `scm_t_array_dim' structures returned by this function can be used
     calculate the position of an element in the storage block of the
     array from its indices.

     This position can then be used as an index into the C array pointer
     returned by the various `scm_array_handle_<foo>_elements'
     functions, or with `scm_array_handle_ref' and
     `scm_array_handle_set'.

     Here is how one can compute the position POS of an element given
     its indices in the vector INDICES:

          ssize_t indices[RANK];
          scm_t_array_dim *dims;
          ssize_t pos;
          size_t i;

          pos = 0;
          for (i = 0; i < RANK; i++)
            {
              if (indices[i] < dims[i].lbnd || indices[i] > dims[i].ubnd)
                out_of_range ();
              pos += (indices[i] - dims[i].lbnd) * dims[i].inc;
            }

 -- C Function: ssize_t scm_array_handle_pos (scm_t_array_handle
          *handle, SCM indices)
     Compute the position corresponding to INDICES, a list of indices.
     The position is computed as described above for
     `scm_array_handle_dims'.  The number of the indices and their
     range is checked and an approrpiate error is signalled for invalid
     indices.

 -- C Function: SCM scm_array_handle_ref (scm_t_array_handle *handle,
          ssize_t pos)
     Return the element at position POS in the storage block of the
     array represented by HANDLE.  Any kind of array is acceptable.  No
     range checking is done on POS.

 -- C Function: void scm_array_handle_set (scm_t_array_handle *handle,
          ssize_t pos, SCM val)
     Set the element at position POS in the storage block of the array
     represented by HANDLE to VAL.  Any kind of array is acceptable.
     No range checking is done on POS.  An error is signalled when the
     array can not store VAL.

 -- C Function: const SCM * scm_array_handle_elements
          (scm_t_array_handle *handle)
     Return a pointer to the elements of a ordinary array of general
     Scheme values (i.e., a non-uniform array) for reading.  This
     pointer is valid as long as the array remains reserved.

 -- C Function: SCM * scm_array_handle_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_elements', but the pointer is good for
     reading and writing.

 -- C Function: const void * scm_array_handle_uniform_elements
          (scm_t_array_handle *handle)
     Return a pointer to the elements of a uniform numeric array for
     reading.  This pointer is valid as long as the array remains
     reserved.  The size of each element is given by
     `scm_array_handle_uniform_element_size'.

 -- C Function: void * scm_array_handle_uniform_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_uniform_elements', but the pointer is good
     reading and writing.

 -- C Function: size_t scm_array_handle_uniform_element_size
          (scm_t_array_handle *handle)
     Return the size of one element of the uniform numeric array
     represented by HANDLE.

 -- C Function: const scm_t_uint8 * scm_array_handle_u8_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int8 * scm_array_handle_s8_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_uint16 * scm_array_handle_u16_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int16 * scm_array_handle_s16_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_uint32 * scm_array_handle_u32_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int32 * scm_array_handle_s32_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_uint64 * scm_array_handle_u64_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int64 * scm_array_handle_s64_elements
          (scm_t_array_handle *handle)
 -- C Function: const float * scm_array_handle_f32_elements
          (scm_t_array_handle *handle)
 -- C Function: const double * scm_array_handle_f64_elements
          (scm_t_array_handle *handle)
 -- C Function: const float * scm_array_handle_c32_elements
          (scm_t_array_handle *handle)
 -- C Function: const double * scm_array_handle_c64_elements
          (scm_t_array_handle *handle)
     Return a pointer to the elements of a uniform numeric array of the
     indicated kind for reading.  This pointer is valid as long as the
     array remains reserved.

     The pointers for `c32' and `c64' uniform numeric arrays point to
     pairs of floating point numbers.  The even index holds the real
     part, the odd index the imaginary part of the complex number.

 -- C Function: scm_t_uint8 * scm_array_handle_u8_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int8 * scm_array_handle_s8_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_uint16 * scm_array_handle_u16_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int16 * scm_array_handle_s16_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_uint32 * scm_array_handle_u32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int32 * scm_array_handle_s32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_uint64 * scm_array_handle_u64_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int64 * scm_array_handle_s64_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: float * scm_array_handle_f32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: double * scm_array_handle_f64_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: float * scm_array_handle_c32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: double * scm_array_handle_c64_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_<kind>_elements', but the pointer is good
     for reading and writing.

 -- C Function: const scm_t_uint32 * scm_array_handle_bit_elements
          (scm_t_array_handle *handle)
     Return a pointer to the words that store the bits of the
     represented array, which must be a bit array.

     Unlike other arrays, bit arrays have an additional offset that
     must be figured into index calculations.  That offset is returned
     by `scm_array_handle_bit_elements_offset'.

     To find a certain bit you first need to calculate its position as
     explained above for `scm_array_handle_dims' and then add the
     offset.  This gives the absolute position of the bit, which is
     always a non-negative integer.

     Each word of the bit array storage block contains exactly 32 bits,
     with the least significant bit in that word having the lowest
     absolute position number.  The next word contains the next 32 bits.

     Thus, the following code can be used to access a bit whose position
     according to `scm_array_handle_dims' is given in POS:

          SCM bit_array;
          scm_t_array_handle handle;
          scm_t_uint32 *bits;
          ssize_t pos;
          size_t abs_pos;
          size_t word_pos, mask;

          scm_array_get_handle (&bit_array, &handle);
          bits = scm_array_handle_bit_elements (&handle);

          pos = ...
          abs_pos = pos + scm_array_handle_bit_elements_offset (&handle);
          word_pos = abs_pos / 32;
          mask = 1L << (abs_pos % 32);

          if (bits[word_pos] & mask)
            /* bit is set. */

          scm_array_handle_release (&handle);


 -- C Function: scm_t_uint32 * scm_array_handle_bit_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_bit_elements' but the pointer is good for
     reading and writing.  You must take care not to modify bits
     outside of the allowed index range of the array, even for
     contiguous arrays.


File: guile.info,  Node: Records,  Next: Structures,  Prev: Arrays,  Up: Compound Data Types

5.6.8 Records
-------------

A "record type" is a first class object representing a user-defined
data type.  A "record" is an instance of a record type.

 -- Scheme Procedure: record? obj
     Return `#t' if OBJ is a record of any type and `#f' otherwise.

     Note that `record?' may be true of any Scheme value; there is no
     promise that records are disjoint with other Scheme types.

 -- Scheme Procedure: make-record-type type-name field-names [print]
     Create and return a new "record-type descriptor".

     TYPE-NAME is a string naming the type.  Currently it's only used
     in the printed representation of records, and in diagnostics.
     FIELD-NAMES is a list of symbols naming the fields of a record of
     the type.  Duplicates are not allowed among these symbols.

          (make-record-type "employee" '(name age salary))

     The optional PRINT argument is a function used by `display',
     `write', etc, for printing a record of the new type.  It's called
     as `(PRINT record port)' and should look at RECORD and write to
     PORT.

 -- Scheme Procedure: record-constructor rtd [field-names]
     Return a procedure for constructing new members of the type
     represented by RTD.  The returned procedure accepts exactly as
     many arguments as there are symbols in the given list,
     FIELD-NAMES; these are used, in order, as the initial values of
     those fields in a new record, which is returned by the constructor
     procedure.  The values of any fields not named in that list are
     unspecified.  The FIELD-NAMES argument defaults to the list of
     field names in the call to `make-record-type' that created the
     type represented by RTD; if the FIELD-NAMES argument is provided,
     it is an error if it contains any duplicates or any symbols not in
     the default list.

 -- Scheme Procedure: record-predicate rtd
     Return a procedure for testing membership in the type represented
     by RTD.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 -- Scheme Procedure: record-accessor rtd field-name
     Return a procedure for reading the value of a particular field of a
     member of the type represented by RTD.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol FIELD-NAME in that record.  The symbol FIELD-NAME
     must be a member of the list of field-names in the call to
     `make-record-type' that created the type represented by RTD.

 -- Scheme Procedure: record-modifier rtd field-name
     Return a procedure for writing the value of a particular field of a
     member of the type represented by RTD.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol FIELD-NAME in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol FIELD-NAME must be a member of the list
     of field-names in the call to `make-record-type' that created the
     type represented by RTD.

 -- Scheme Procedure: record-type-descriptor record
     Return a record-type descriptor representing the type of the given
     record.  That is, for example, if the returned descriptor were
     passed to `record-predicate', the resulting predicate would return
     a true value when passed the given record.  Note that it is not
     necessarily the case that the returned descriptor is the one that
     was passed to `record-constructor' in the call that created the
     constructor procedure that created the given record.

 -- Scheme Procedure: record-type-name rtd
     Return the type-name associated with the type represented by rtd.
     The returned value is `eqv?' to the TYPE-NAME argument given in
     the call to `make-record-type' that created the type represented by
     RTD.

 -- Scheme Procedure: record-type-fields rtd
     Return a list of the symbols naming the fields in members of the
     type represented by RTD.  The returned value is `equal?' to the
     field-names argument given in the call to `make-record-type' that
     created the type represented by RTD.


File: guile.info,  Node: Structures,  Next: Dictionary Types,  Prev: Records,  Up: Compound Data Types

5.6.9 Structures
----------------

A "structure" is a first class data type which holds Scheme values or C
words in fields numbered 0 upwards.  A "vtable" represents a structure
type, giving field types and permissions, and an optional print
function for `write' etc.

   Structures are lower level than records (*note Records::) but have
some extra features.  The vtable system allows sets of types be
constructed, with class data.  The uninterpreted words can
inter-operate with C code, allowing arbitrary pointers or other values
to be stored along side usual Scheme `SCM' values.

* Menu:

* Vtables::
* Structure Basics::
* Vtable Contents::
* Vtable Vtables::


File: guile.info,  Node: Vtables,  Next: Structure Basics,  Prev: Structures,  Up: Structures

5.6.9.1 Vtables
...............

A vtable is a structure type, specifying its layout, and other
information.  A vtable is actually itself a structure, but there's no
need to worray about that initially (*note Vtable Contents::.)

 -- Scheme Procedure: make-vtable fields [print]
     Create a new vtable.

     FIELDS is a string describing the fields in the structures to be
     created.  Each field is represented by two characters, a type
     letter and a permissions letter, for example `"pw"'.  The types
     are as follows.

        * `p' - a Scheme value.  "p" stands for "protected" meaning
          it's protected against garbage collection.

        * `u' - an arbitrary word of data (an `scm_t_bits').  At the
          Scheme level it's read and written as an unsigned integer.
          "u" stands for "uninterpreted" (it's not treated as a Scheme
          value), or "unprotected" (it's not marked during GC), or
          "unsigned long" (its size), or all of these things.

        * `s' - a self-reference.  Such a field holds the `SCM' value
          of the structure itself (a circular reference).  This can be
          useful in C code where you might have a pointer to the data
          array, and want to get the Scheme `SCM' handle for the
          structure.  In Scheme code it has no use.

     The second letter for each field is a permission code,

        * `w' - writable, the field can be read and written.

        * `r' - read-only, the field can be read but not written.

        * `o' - opaque, the field can be neither read nor written at the
          Scheme level.  This can be used for fields which should only
          be used from C code.

        * `W',`R',`O' - a tail array, with permissions for the array
          fields as per `w',`r',`o'.

     A tail array is further fields at the end of a structure.  The last
     field in the layout string might be for instance `pW' to have a
     tail of writable Scheme-valued fields.  The `pW' field itself
     holds the tail size, and the tail fields come after it.

     Here are some examples.

          (make-vtable "pw")      ;; one writable field
          (make-vtable "prpw")    ;; one read-only and one writable
          (make-vtable "pwuwuw")  ;; one scheme and two uninterpreted

          (make-vtable "prpW")    ;; one fixed then a tail array

     The optional PRINT argument is a function called by `display' and
     `write' (etc) to give a printed representation of a structure
     created from this vtable.  It's called `(PRINT struct port)' and
     should look at STRUCT and write to PORT.  The default print merely
     gives a form like `#<struct ADDR:ADDR>' with a pair of machine
     addresses.

     The following print function for example shows the two fields of
     its structure.

          (make-vtable "prpw"
                       (lambda (struct port)
                         (display "#<")
                         (display (struct-ref 0))
                         (display " and ")
                         (display (struct-ref 1))
                         (display ">")))


File: guile.info,  Node: Structure Basics,  Next: Vtable Contents,  Prev: Vtables,  Up: Structures

5.6.9.2 Structure Basics
........................

This section describes the basic procedures for working with
structures.  `make-struct' creates a structure, and `struct-ref' and
`struct-set!' access write fields.

 -- Scheme Procedure: make-struct vtable tail-size [init...]
 -- C Function: scm_make_struct (vtable, tail_size, init_list)
     Create a new structure, with layout per the given VTABLE (*note
     Vtables::).

     TAIL-SIZE is the size of the tail array if VTABLE specifies a tail
     array.  TAIL-SIZE should be 0 when VTABLE doesn't specify a tail
     array.

     The optional INIT... arguments are initial values for the fields
     of the structure (and the tail array).  This is the only way to
     put values in read-only fields.  If there are fewer INIT arguments
     than fields then the defaults are `#f' for a Scheme field (type
     `p') or 0 for an uninterpreted field (type `u').

     Type `s' self-reference fields, permission `o' opaque fields, and
     the count field of a tail array are all ignored for the INIT
     arguments, ie. an argument is not consumed by such a field.  An
     `s' is always set to the structure itself, an `o' is always set to
     `#f' or 0 (with the intention that C code will do something to it
     later), and the tail count is always the given TAIL-SIZE.

     For example,

          (define v (make-vtable "prpwpw"))
          (define s (make-struct v 0 123 "abc" 456))
          (struct-ref s 0) => 123
          (struct-ref s 1) => "abc"

          (define v (make-vtable "prpW"))
          (define s (make-struct v 6 "fixed field" 'x 'y))
          (struct-ref s 0) => "fixed field"
          (struct-ref s 1) => 2    ;; tail size
          (struct-ref s 2) => x    ;; tail array ...
          (struct-ref s 3) => y
          (struct-ref s 4) => #f

 -- Scheme Procedure: struct? obj
 -- C Function: scm_struct_p (obj)
     Return `#t' if OBJ is a structure, or `#f' if not.

 -- Scheme Procedure: struct-ref struct n
 -- C Function: scm_struct_ref (struct, n)
     Return the contents of field number N in STRUCT.  The first field
     is number 0.

     An error is thrown if N is out of range, or if the field cannot be
     read because it's `o' opaque.

 -- Scheme Procedure: struct-set! struct n value
 -- C Function: scm_struct_set_x (struct, n, value)
     Set field number N in STRUCT to VALUE.  The first field is number
     0.

     An error is thrown if N is out of range, or if the field cannot be
     written because it's `r' read-only or `o' opaque.

 -- Scheme Procedure: struct-vtable struct
 -- C Function: scm_struct_vtable (struct)
     Return the vtable used by STRUCT.

     This can be used to examine the layout of an unknown structure, see
     *note Vtable Contents::.


File: guile.info,  Node: Vtable Contents,  Next: Vtable Vtables,  Prev: Structure Basics,  Up: Structures

5.6.9.3 Vtable Contents
.......................

A vtable is itself a structure, with particular fields that hold
information about the structures to be created.  These include the
fields of those structures, and the print function for them.  The
variables below allow access to those fields.

 -- Scheme Procedure: struct-vtable? obj
 -- C Function: scm_struct_vtable_p (obj)
     Return `#t' if OBJ is a vtable structure.

     Note that because vtables are simply structures with a particular
     layout, `struct-vtable?' can potentially return true on an
     application structure which merely happens to look like a vtable.

 -- Scheme Variable: vtable-index-layout
 -- C Macro: scm_vtable_index_layout
     The field number of the layout specification in a vtable.  The
     layout specification is a symbol like `pwpw' formed from the fields
     string passed to `make-vtable', or created by `make-struct-layout'
     (*note Vtable Vtables::).

          (define v (make-vtable "pwpw" 0))
          (struct-ref v vtable-index-layout) => pwpw

     This field is read-only, since the layout of structures using a
     vtable cannot be changed.

 -- Scheme Variable: vtable-index-vtable
 -- C Macro: scm_vtable_index_vtable
     A self-reference to the vtable, ie. a type `s' field.  This is
     used by C code within Guile and has no use at the Scheme level.

 -- Scheme Variable: vtable-index-printer
 -- C Macro: scm_vtable_index_printer
     The field number of the printer function.  This field contains `#f'
     if the default print function should be used.

          (define (my-print-func struct port)
            ...)
          (define v (make-vtable "pwpw" my-print-func))
          (struct-ref v vtable-index-printer) => my-print-func

     This field is writable, allowing the print function to be changed
     dynamically.

 -- Scheme Procedure: struct-vtable-name vtable
 -- Scheme Procedure: set-struct-vtable-name! vtable name
 -- C Function: scm_struct_vtable_name (vtable)
 -- C Function: scm_set_struct_vtable_name_x (vtable, name)
     Get or set the name of VTABLE.  NAME is a symbol and is used in
     the default print function when printing structures created from
     VTABLE.

          (define v (make-vtable "pw"))
          (set-struct-vtable-name! v 'my-name)

          (define s (make-struct v 0))
          (display s) -| #<my-name b7ab3ae0:b7ab3730>

 -- Scheme Procedure: struct-vtable-tag vtable
 -- C Function: scm_struct_vtable_tag (vtable)
     Return the tag of the given VTABLE.


File: guile.info,  Node: Vtable Vtables,  Prev: Vtable Contents,  Up: Structures

5.6.9.4 Vtable Vtables
......................

As noted above, a vtable is a structure and that structure is itself
described by a vtable.  Such a "vtable of a vtable" can be created with
`make-vtable-vtable' below.  This can be used to build sets of related
vtables, possibly with extra application fields.

   This second level of vtable can be a little confusing.  The ball
example below is a typical use, adding a "class data" field to the
vtables, from which instance structures are created.  The current
implementation of Guile's own records (*note Records::) does something
similar, a record type descriptor is a vtable with room to hold the
field names of the records to be created from it.

 -- Scheme Procedure: make-vtable-vtable user-fields tail-size [print]
 -- C Function: scm_make_vtable_vtable (user_fields, tail_size,
          print_and_init_list)
     Create a "vtable-vtable" which can be used to create vtables.  This
     vtable-vtable is also a vtable, and is self-describing, meaning its
     vtable is itself.  The following is a simple usage.

          (define vt-vt (make-vtable-vtable "" 0))
          (define vt    (make-struct vt-vt 0
                                     (make-struct-layout "pwpw"))
          (define s     (make-struct vt 0 123 456))

          (struct-ref s 0) => 123

     `make-struct' is used to create a vtable from the vtable-vtable.
     The first initializer is a layout object (field
     `vtable-index-layout'), usually obtained from `make-struct-layout'
     (below).  An optional second initializer is a printer function
     (field `vtable-index-printer'), used as described under
     `make-vtable' (*note Vtables::).


     USER-FIELDS is a layout string giving extra fields to have in the
     vtables.  A vtable starts with some base fields as per *note
     Vtable Contents::, and USER-FIELDS is appended.  The USER-FIELDS
     start at field number `vtable-offset-user' (below), and exist in
     both the vtable-vtable and in the vtables created from it.  Such
     fields provide space for "class data".  For example,

          (define vt-of-vt (make-vtable-vtable "pw" 0))
          (define vt       (make-struct vt-of-vt 0))
          (struct-set! vt vtable-offset-user "my class data")

     TAIL-SIZE is the size of the tail array in the vtable-vtable
     itself, if USER-FIELDS specifies a tail array.  This should be 0
     if nothing extra is required or the format has no tail array.  The
     tail array field such as `pW' holds the tail array size, as usual,
     and is followed by the extra space.

          (define vt-vt (make-vtable-vtable "pW" 20))
          (define my-vt-tail-start (1+ vtable-offset-user))
          (struct-set! vt-vt (+ 3 my-vt-tail-start) "data in tail")

     The optional PRINT argument is used by `display' and `write' (etc)
     to print the vtable-vtable and any vtables created from it.  It's
     called as `(PRINT vtable port)' and should look at VTABLE and
     write to PORT.  The default is the usual structure print function,
     which just gives machine addresses.

 -- Scheme Procedure: make-struct-layout fields
 -- C Function: scm_make_struct_layout (fields)
     Return a structure layout symbol, from a FIELDS string.  FIELDS is
     as described under `make-vtable' (*note Vtables::).  An invalid
     FIELDS string is an error.

          (make-struct-layout "prpW") => prpW
          (make-struct-layout "blah") => ERROR

 -- Scheme Variable: vtable-offset-user
 -- C Macro: scm_vtable_offset_user
     The first field in a vtable which is available for application use.
     Such fields only exist when specified by USER-FIELDS in
     `make-vtable-vtable' above.


   Here's an extended vtable-vtable example, creating classes of
"balls".  Each class has a "colour", which is fixed.  Instances of
those classes are created, and such each such ball has an "owner",
which can be changed.

     (define ball-root (make-vtable-vtable "pr" 0))

     (define (make-ball-type ball-color)
       (make-struct ball-root 0
     	       (make-struct-layout "pw")
                    (lambda (ball port)
                      (format port "#<a ~A ball owned by ~A>"
                              (color ball)
                              (owner ball)))
                    ball-color))
     (define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
     (define (owner ball) (struct-ref ball 0))

     (define red (make-ball-type 'red))
     (define green (make-ball-type 'green))

     (define (make-ball type owner) (make-struct type 0 owner))

     (define ball (make-ball green 'Nisse))
     ball => #<a green ball owned by Nisse>


File: guile.info,  Node: Dictionary Types,  Next: Association Lists,  Prev: Structures,  Up: Compound Data Types

5.6.10 Dictionary Types
-----------------------

A "dictionary" object is a data structure used to index information in
a user-defined way.  In standard Scheme, the main aggregate data types
are lists and vectors.  Lists are not really indexed at all, and
vectors are indexed only by number (e.g. `(vector-ref foo 5)').  Often
you will find it useful to index your data on some other type; for
example, in a library catalog you might want to look up a book by the
name of its author.  Dictionaries are used to help you organize
information in such a way.

   An "association list" (or "alist" for short) is a list of key-value
pairs.  Each pair represents a single quantity or object; the `car' of
the pair is a key which is used to identify the object, and the `cdr'
is the object's value.

   A "hash table" also permits you to index objects with arbitrary
keys, but in a way that makes looking up any one object extremely fast.
A well-designed hash system makes hash table lookups almost as fast as
conventional array or vector references.

   Alists are popular among Lisp programmers because they use only the
language's primitive operations (lists, "car", "cdr" and the equality
primitives).  No changes to the language core are necessary.
Therefore, with Scheme's built-in list manipulation facilities, it is
very convenient to handle data stored in an association list.  Also,
alists are highly portable and can be easily implemented on even the
most minimal Lisp systems.

   However, alists are inefficient, especially for storing large
quantities of data.  Because we want Guile to be useful for large
software systems as well as small ones, Guile provides a rich set of
tools for using either association lists or hash tables.


File: guile.info,  Node: Association Lists,  Next: Hash Tables,  Prev: Dictionary Types,  Up: Compound Data Types

5.6.11 Association Lists
------------------------

An association list is a conventional data structure that is often used
to implement simple key-value databases.  It consists of a list of
entries in which each entry is a pair.  The "key" of each entry is the
`car' of the pair and the "value" of each entry is the `cdr'.

     ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)
                              (KEY2 . VALUE2)
                              (KEY3 . VALUE3)
                              ...
                            )

Association lists are also known, for short, as "alists".

   The structure of an association list is just one example of the
infinite number of possible structures that can be built using pairs
and lists.  As such, the keys and values in an association list can be
manipulated using the general list structure procedures `cons', `car',
`cdr', `set-car!', `set-cdr!' and so on.  However, because association
lists are so useful, Guile also provides specific procedures for
manipulating them.

* Menu:

* Alist Key Equality::
* Adding or Setting Alist Entries::
* Retrieving Alist Entries::
* Removing Alist Entries::
* Sloppy Alist Functions::
* Alist Example::


File: guile.info,  Node: Alist Key Equality,  Next: Adding or Setting Alist Entries,  Up: Association Lists

5.6.11.1 Alist Key Equality
...........................

All of Guile's dedicated association list procedures, apart from
`acons', come in three flavours, depending on the level of equality
that is required to decide whether an existing key in the association
list is the same as the key that the procedure call uses to identify the
required entry.

   * Procedures with "assq" in their name use `eq?' to determine key
     equality.

   * Procedures with "assv" in their name use `eqv?' to determine key
     equality.

   * Procedures with "assoc" in their name use `equal?' to determine
     key equality.

   `acons' is an exception because it is used to build association
lists which do not require their entries' keys to be unique.


File: guile.info,  Node: Adding or Setting Alist Entries,  Next: Retrieving Alist Entries,  Prev: Alist Key Equality,  Up: Association Lists

5.6.11.2 Adding or Setting Alist Entries
........................................

`acons' adds a new entry to an association list and returns the
combined association list.  The combined alist is formed by consing the
new entry onto the head of the alist specified in the `acons' procedure
call.  So the specified alist is not modified, but its contents become
shared with the tail of the combined alist that `acons' returns.

   In the most common usage of `acons', a variable holding the original
association list is updated with the combined alist:

     (set! address-list (acons name address address-list))

   In such cases, it doesn't matter that the old and new values of
`address-list' share some of their contents, since the old value is
usually no longer independently accessible.

   Note that `acons' adds the specified new entry regardless of whether
the alist may already contain entries with keys that are, in some
sense, the same as that of the new entry.  Thus `acons' is ideal for
building alists where there is no concept of key uniqueness.

     (set! task-list (acons 3 "pay gas bill" '()))
     task-list
     =>
     ((3 . "pay gas bill"))

     (set! task-list (acons 3 "tidy bedroom" task-list))
     task-list
     =>
     ((3 . "tidy bedroom") (3 . "pay gas bill"))

   `assq-set!', `assv-set!' and `assoc-set!' are used to add or replace
an entry in an association list where there _is_ a concept of key
uniqueness.  If the specified association list already contains an
entry whose key is the same as that specified in the procedure call,
the existing entry is replaced by the new one.  Otherwise, the new
entry is consed onto the head of the old association list to create the
combined alist.  In all cases, these procedures return the combined
alist.

   `assq-set!' and friends _may_ destructively modify the structure of
the old association list in such a way that an existing variable is
correctly updated without having to `set!' it to the value returned:

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "16 Bow Street"))

     (assoc-set! address-list "james" "1a London Road")
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

   Or they may not:

     (assoc-set! address-list "bob" "11 Newington Avenue")
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

   The only safe way to update an association list variable when adding
or replacing an entry like this is to `set!' the variable to the
returned value:

     (set! address-list
           (assoc-set! address-list "bob" "11 Newington Avenue"))
     address-list
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

   Because of this slight inconvenience, you may find it more
convenient to use hash tables to store dictionary data.  If your
application will not be modifying the contents of an alist very often,
this may not make much difference to you.

   If you need to keep the old value of an association list in a form
independent from the list that results from modification by `acons',
`assq-set!', `assv-set!' or `assoc-set!', use `list-copy' to copy the
old association list before modifying it.

 -- Scheme Procedure: acons key value alist
 -- C Function: scm_acons (key, value, alist)
     Add a new key-value pair to ALIST.  A new pair is created whose
     car is KEY and whose cdr is VALUE, and the pair is consed onto
     ALIST, and the new list is returned.  This function is _not_
     destructive; ALIST is not modified.

 -- Scheme Procedure: assq-set! alist key val
 -- Scheme Procedure: assv-set! alist key value
 -- Scheme Procedure: assoc-set! alist key value
 -- C Function: scm_assq_set_x (alist, key, val)
 -- C Function: scm_assv_set_x (alist, key, val)
 -- C Function: scm_assoc_set_x (alist, key, val)
     Reassociate KEY in ALIST with VALUE: find any existing ALIST entry
     for KEY and associate it with the new VALUE.  If ALIST does not
     contain an entry for KEY, add a new one.  Return the (possibly
     new) alist.

     These functions do not attempt to verify the structure of ALIST,
     and so may cause unusual results if passed an object that is not an
     association list.


File: guile.info,  Node: Retrieving Alist Entries,  Next: Removing Alist Entries,  Prev: Adding or Setting Alist Entries,  Up: Association Lists

5.6.11.3 Retrieving Alist Entries
.................................

`assq', `assv' and `assoc' find the entry in an alist for a given key,
and return the `(KEY . VALUE)' pair.  `assq-ref', `assv-ref' and
`assoc-ref' do a similar lookup, but return just the VALUE.

 -- Scheme Procedure: assq key alist
 -- Scheme Procedure: assv key alist
 -- Scheme Procedure: assoc key alist
 -- C Function: scm_assq (key, alist)
 -- C Function: scm_assv (key, alist)
 -- C Function: scm_assoc (key, alist)
     Return the first entry in ALIST with the given KEY.  The return is
     the pair `(KEY . VALUE)' from ALIST.  If there's no matching entry
     the return is `#f'.

     `assq' compares keys with `eq?', `assv' uses `eqv?' and `assoc'
     uses `equal?'.  See also SRFI-1 which has an extended `assoc'
     (*note SRFI-1 Association Lists::).

 -- Scheme Procedure: assq-ref alist key
 -- Scheme Procedure: assv-ref alist key
 -- Scheme Procedure: assoc-ref alist key
 -- C Function: scm_assq_ref (alist, key)
 -- C Function: scm_assv_ref (alist, key)
 -- C Function: scm_assoc_ref (alist, key)
     Return the value from the first entry in ALIST with the given KEY,
     or `#f' if there's no such entry.

     `assq-ref' compares keys with `eq?', `assv-ref' uses `eqv?' and
     `assoc-ref' uses `equal?'.

     Notice these functions have the KEY argument last, like other
     `-ref' functions, but this is opposite to what what `assq' etc
     above use.

     When the return is `#f' it can be either KEY not found, or an
     entry which happens to have value `#f' in the `cdr'.  Use `assq'
     etc above if you need to differentiate these cases.


File: guile.info,  Node: Removing Alist Entries,  Next: Sloppy Alist Functions,  Prev: Retrieving Alist Entries,  Up: Association Lists

5.6.11.4 Removing Alist Entries
...............................

To remove the element from an association list whose key matches a
specified key, use `assq-remove!', `assv-remove!' or `assoc-remove!'
(depending, as usual, on the level of equality required between the key
that you specify and the keys in the association list).

   As with `assq-set!' and friends, the specified alist may or may not
be modified destructively, and the only safe way to update a variable
containing the alist is to `set!' it to the value that `assq-remove!'
and friends return.

     address-list
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

     (set! address-list (assoc-remove! address-list "mary"))
     address-list
     =>
     (("bob" . "11 Newington Avenue") ("james" . "1a London Road"))

   Note that, when `assq/v/oc-remove!' is used to modify an association
list that has been constructed only using the corresponding
`assq/v/oc-set!', there can be at most one matching entry in the alist,
so the question of multiple entries being removed in one go does not
arise.  If `assq/v/oc-remove!' is applied to an association list that
has been constructed using `acons', or an `assq/v/oc-set!' with a
different level of equality, or any mixture of these, it removes only
the first matching entry from the alist, even if the alist might
contain further matching entries.  For example:

     (define address-list '())
     (set! address-list (assq-set! address-list "mary" "11 Elm Street"))
     (set! address-list (assq-set! address-list "mary" "57 Pine Drive"))
     address-list
     =>
     (("mary" . "57 Pine Drive") ("mary" . "11 Elm Street"))

     (set! address-list (assoc-remove! address-list "mary"))
     address-list
     =>
     (("mary" . "11 Elm Street"))

   In this example, the two instances of the string "mary" are not the
same when compared using `eq?', so the two `assq-set!' calls add two
distinct entries to `address-list'.  When compared using `equal?', both
"mary"s in `address-list' are the same as the "mary" in the
`assoc-remove!' call, but `assoc-remove!' stops after removing the
first matching entry that it finds, and so one of the "mary" entries is
left in place.

 -- Scheme Procedure: assq-remove! alist key
 -- Scheme Procedure: assv-remove! alist key
 -- Scheme Procedure: assoc-remove! alist key
 -- C Function: scm_assq_remove_x (alist, key)
 -- C Function: scm_assv_remove_x (alist, key)
 -- C Function: scm_assoc_remove_x (alist, key)
     Delete the first entry in ALIST associated with KEY, and return
     the resulting alist.


File: guile.info,  Node: Sloppy Alist Functions,  Next: Alist Example,  Prev: Removing Alist Entries,  Up: Association Lists

5.6.11.5 Sloppy Alist Functions
...............................

`sloppy-assq', `sloppy-assv' and `sloppy-assoc' behave like the
corresponding non-`sloppy-' procedures, except that they return `#f'
when the specified association list is not well-formed, where the
non-`sloppy-' versions would signal an error.

   Specifically, there are two conditions for which the non-`sloppy-'
procedures signal an error, which the `sloppy-' procedures handle
instead by returning `#f'.  Firstly, if the specified alist as a whole
is not a proper list:

     (assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
     =>
     ERROR: In procedure assoc in expression (assoc "mary" (quote #)):
     ERROR: Wrong type argument in position 2 (expecting association list): ((1 . 2) ("key" . "door") . "open sesame")

     (sloppy-assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
     =>
     #f

Secondly, if one of the entries in the specified alist is not a pair:

     (assoc 2 '((1 . 1) 2 (3 . 9)))
     =>
     ERROR: In procedure assoc in expression (assoc 2 (quote #)):
     ERROR: Wrong type argument in position 2 (expecting association list): ((1 . 1) 2 (3 . 9))

     (sloppy-assoc 2 '((1 . 1) 2 (3 . 9)))
     =>
     #f

   Unless you are explicitly working with badly formed association
lists, it is much safer to use the non-`sloppy-' procedures, because
they help to highlight coding and data errors that the `sloppy-'
versions would silently cover up.

 -- Scheme Procedure: sloppy-assq key alist
 -- C Function: scm_sloppy_assq (key, alist)
     Behaves like `assq' but does not do any error checking.
     Recommended only for use in Guile internals.

 -- Scheme Procedure: sloppy-assv key alist
 -- C Function: scm_sloppy_assv (key, alist)
     Behaves like `assv' but does not do any error checking.
     Recommended only for use in Guile internals.

 -- Scheme Procedure: sloppy-assoc key alist
 -- C Function: scm_sloppy_assoc (key, alist)
     Behaves like `assoc' but does not do any error checking.
     Recommended only for use in Guile internals.


File: guile.info,  Node: Alist Example,  Prev: Sloppy Alist Functions,  Up: Association Lists

5.6.11.6 Alist Example
......................

Here is a longer example of how alists may be used in practice.

     (define capitals '(("New York" . "Albany")
                        ("Oregon"   . "Salem")
                        ("Florida"  . "Miami")))

     ;; What's the capital of Oregon?
     (assoc "Oregon" capitals)       => ("Oregon" . "Salem")
     (assoc-ref capitals "Oregon")   => "Salem"

     ;; We left out South Dakota.
     (set! capitals
           (assoc-set! capitals "South Dakota" "Pierre"))
     capitals
     => (("South Dakota" . "Pierre")
         ("New York" . "Albany")
         ("Oregon" . "Salem")
         ("Florida" . "Miami"))

     ;; And we got Florida wrong.
     (set! capitals
           (assoc-set! capitals "Florida" "Tallahassee"))
     capitals
     => (("South Dakota" . "Pierre")
         ("New York" . "Albany")
         ("Oregon" . "Salem")
         ("Florida" . "Tallahassee"))

     ;; After Oregon secedes, we can remove it.
     (set! capitals
           (assoc-remove! capitals "Oregon"))
     capitals
     => (("South Dakota" . "Pierre")
         ("New York" . "Albany")
         ("Florida" . "Tallahassee"))


File: guile.info,  Node: Hash Tables,  Prev: Association Lists,  Up: Compound Data Types

5.6.12 Hash Tables
------------------

Hash tables are dictionaries which offer similar functionality as
association lists: They provide a mapping from keys to values.  The
difference is that association lists need time linear in the size of
elements when searching for entries, whereas hash tables can normally
search in constant time.  The drawback is that hash tables require a
little bit more memory, and that you can not use the normal list
procedures (*note Lists::) for working with them.

   Guile provides two types of hashtables.  One is an abstract data type
that can only be manipulated with the functions in this section.  The
other type is concrete: it uses a normal vector with alists as
elements.  The advantage of the abstract hash tables is that they will
be automatically resized when they become too full or too empty.

* Menu:

* Hash Table Examples::         Demonstration of hash table usage.
* Hash Table Reference::        Hash table procedure descriptions.


File: guile.info,  Node: Hash Table Examples,  Next: Hash Table Reference,  Up: Hash Tables

5.6.12.1 Hash Table Examples
............................

For demonstration purposes, this section gives a few usage examples of
some hash table procedures, together with some explanation what they do.

   First we start by creating a new hash table with 31 slots, and
populate it with two key/value pairs.

     (define h (make-hash-table 31))

     ;; This is an opaque object
     h
     =>
     #<hash-table 0/31>

     ;; We can also use a vector of alists.
     (define h (make-vector 7 '()))

     h
     =>
     #(() () () () () () ())

     ;; Inserting into a hash table can be done with hashq-set!
     (hashq-set! h 'foo "bar")
     =>
     "bar"

     (hashq-set! h 'braz "zonk")
     =>
     "zonk"

     ;; Or with hash-create-handle!
     (hashq-create-handle! h 'frob #f)
     =>
     (frob . #f)

     ;; The vector now contains three elements in the alists and the frob
     ;; entry is at index (hashq 'frob).
     h
     =>
     #(() () () () ((frob . #f) (braz . "zonk")) () ((foo . "bar")))

     (hashq 'frob)
     =>
     4

   You can get the value for a given key with the procedure
`hashq-ref', but the problem with this procedure is that you cannot
reliably determine whether a key does exists in the table.  The reason
is that the procedure returns `#f' if the key is not in the table, but
it will return the same value if the key is in the table and just
happens to have the value `#f', as you can see in the following
examples.

     (hashq-ref h 'foo)
     =>
     "bar"

     (hashq-ref h 'frob)
     =>
     #f

     (hashq-ref h 'not-there)
     =>
     #f

   Better is to use the procedure `hashq-get-handle', which makes a
distinction between the two cases.  Just like `assq', this procedure
returns a key/value-pair on success, and `#f' if the key is not found.

     (hashq-get-handle h 'foo)
     =>
     (foo . "bar")

     (hashq-get-handle h 'not-there)
     =>
     #f

   There is no procedure for calculating the number of key/value-pairs
in a hash table, but `hash-fold' can be used for doing exactly that.

     (hash-fold (lambda (key value seed) (+ 1 seed)) 0 h)
     =>
     3


File: guile.info,  Node: Hash Table Reference,  Prev: Hash Table Examples,  Up: Hash Tables

5.6.12.2 Hash Table Reference
.............................

Like the association list functions, the hash table functions come in
several varieties, according to the equality test used for the keys.
Plain `hash-' functions use `equal?', `hashq-' functions use `eq?',
`hashv-' functions use `eqv?', and the `hashx-' functions use an
application supplied test.

   A single `make-hash-table' creates a hash table suitable for use
with any set of functions, but it's imperative that just one set is
then used consistently, or results will be unpredictable.

   Hash tables are implemented as a vector indexed by a hash value
formed from the key, with an association list of key/value pairs for
each bucket in case distinct keys hash together.  Direct access to the
pairs in those lists is provided by the `-handle-' functions.  The
abstract kind of hash tables hide the vector in an opaque object that
represents the hash table, while for the concrete kind the vector _is_
the hashtable.

   When the number of table entries in an abstract hash table goes above
a threshold, the vector is made larger and the entries are rehashed, to
prevent the bucket lists from becoming too long and slowing down
accesses.  When the number of entries goes below a threshold, the
vector is shrunk to save space.

   A abstract hash table is created with `make-hash-table'.  To create
a vector that is suitable as a hash table, use `(make-vector SIZE
'())', for example.

   For the `hashx-' "extended" routines, an application supplies a HASH
function producing an integer index like `hashq' etc below, and an
ASSOC alist search function like `assq' etc (*note Retrieving Alist
Entries::).  Here's an example of such functions implementing
case-insensitive hashing of string keys,

     (use-modules (srfi srfi-1)
                  (srfi srfi-13))

     (define (my-hash str size)
       (remainder (string-hash-ci str) size))
     (define (my-assoc str alist)
       (find (lambda (pair) (string-ci=? str (car pair))) alist))

     (define my-table (make-hash-table))
     (hashx-set! my-hash my-assoc my-table "foo" 123)

     (hashx-ref my-hash my-assoc my-table "FOO")
     => 123

   In a `hashx-' HASH function the aim is to spread keys across the
vector, so bucket lists don't become long.  But the actual values are
arbitrary as long as they're in the range 0 to SIZE-1.  Helpful
functions for forming a hash value, in addition to `hashq' etc below,
include `symbol-hash' (*note Symbol Keys::), `string-hash' and
`string-hash-ci' (*note String Comparison::), and `char-set-hash'
(*note Character Set Predicates/Comparison::).


 -- Scheme Procedure: make-hash-table [size]
     Create a new abstract hash table object, with an optional minimum
     vector SIZE.

     When SIZE is given, the table vector will still grow and shrink
     automatically, as described above, but with SIZE as a minimum.  If
     an application knows roughly how many entries the table will hold
     then it can use SIZE to avoid rehashing when initial entries are
     added.

 -- Scheme Procedure: hash-table? obj
 -- C Function: scm_hash_table_p (obj)
     Return `#t' if OBJ is a abstract hash table object.

 -- Scheme Procedure: hash-clear! table
 -- C Function: scm_hash_clear_x (table)
     Remove all items from TABLE (without triggering a resize).

 -- Scheme Procedure: hash-ref table key [dflt]
 -- Scheme Procedure: hashq-ref table key [dflt]
 -- Scheme Procedure: hashv-ref table key [dflt]
 -- Scheme Procedure: hashx-ref hash assoc table key [dflt]
 -- C Function: scm_hash_ref (table, key, dflt)
 -- C Function: scm_hashq_ref (table, key, dflt)
 -- C Function: scm_hashv_ref (table, key, dflt)
 -- C Function: scm_hashx_ref (hash, assoc, table, key, dflt)
     Lookup KEY in the given hash TABLE, and return the associated
     value.  If KEY is not found, return DFLT, or `#f' if DFLT is not
     given.

 -- Scheme Procedure: hash-set! table key val
 -- Scheme Procedure: hashq-set! table key val
 -- Scheme Procedure: hashv-set! table key val
 -- Scheme Procedure: hashx-set! hash assoc table key val
 -- C Function: scm_hash_set_x (table, key, val)
 -- C Function: scm_hashq_set_x (table, key, val)
 -- C Function: scm_hashv_set_x (table, key, val)
 -- C Function: scm_hashx_set_x (hash, assoc, table, key, val)
     Associate VAL with KEY in the given hash TABLE.  If KEY is already
     present then it's associated value is changed.  If it's not
     present then a new entry is created.

 -- Scheme Procedure: hash-remove! table key
 -- Scheme Procedure: hashq-remove! table key
 -- Scheme Procedure: hashv-remove! table key
 -- Scheme Procedure: hashx-remove! hash assoc table key
 -- C Function: scm_hash_remove_x (table, key)
 -- C Function: scm_hashq_remove_x (table, key)
 -- C Function: scm_hashv_remove_x (table, key)
 -- C Function: scm_hashx_remove_x (hash, assoc, table, key)
     Remove any association for KEY in the given hash TABLE.  If KEY is
     not in TABLE then nothing is done.

 -- Scheme Procedure: hash key size
 -- Scheme Procedure: hashq key size
 -- Scheme Procedure: hashv key size
 -- C Function: scm_hash (key, size)
 -- C Function: scm_hashq (key, size)
 -- C Function: scm_hashv (key, size)
     Return a hash value for KEY.  This is a number in the range 0 to
     SIZE-1, which is suitable for use in a hash table of the given
     SIZE.

     Note that `hashq' and `hashv' may use internal addresses of
     objects, so if an object is garbage collected and re-created it can
     have a different hash value, even when the two are notionally
     `eq?'.  For instance with symbols,

          (hashq 'something 123)   => 19
          (gc)
          (hashq 'something 123)   => 62

     In normal use this is not a problem, since an object entered into a
     hash table won't be garbage collected until removed.  It's only if
     hashing calculations are somehow separated from normal references
     that its lifetime needs to be considered.

 -- Scheme Procedure: hash-get-handle table key
 -- Scheme Procedure: hashq-get-handle table key
 -- Scheme Procedure: hashv-get-handle table key
 -- Scheme Procedure: hashx-get-handle hash assoc table key
 -- C Function: scm_hash_get_handle (table, key)
 -- C Function: scm_hashq_get_handle (table, key)
 -- C Function: scm_hashv_get_handle (table, key)
 -- C Function: scm_hashx_get_handle (hash, assoc, table, key)
     Return the `(KEY . VALUE)' pair for KEY in the given hash TABLE,
     or `#f' if KEY is not in TABLE.

 -- Scheme Procedure: hash-create-handle! table key init
 -- Scheme Procedure: hashq-create-handle! table key init
 -- Scheme Procedure: hashv-create-handle! table key init
 -- Scheme Procedure: hashx-create-handle! hash assoc table key init
 -- C Function: scm_hash_create_handle_x (table, key, init)
 -- C Function: scm_hashq_create_handle_x (table, key, init)
 -- C Function: scm_hashv_create_handle_x (table, key, init)
 -- C Function: scm_hashx_create_handle_x (hash, assoc, table, key,
          init)
     Return the `(KEY . VALUE)' pair for KEY in the given hash TABLE.
     If KEY is not in TABLE then create an entry for it with INIT as
     the value, and return that pair.

 -- Scheme Procedure: hash-map->list proc table
 -- Scheme Procedure: hash-for-each proc table
 -- C Function: scm_hash_map_to_list (proc, table)
 -- C Function: scm_hash_for_each (proc, table)
     Apply PROC to the entries in the given hash TABLE.  Each call is
     `(PROC KEY VALUE)'.  `hash-map->list' returns a list of the
     results from these calls, `hash-for-each' discards the results and
     returns an unspecified value.

     Calls are made over the table entries in an unspecified order, and
     for `hash-map->list' the order of the values in the returned list
     is unspecified.  Results will be unpredictable if TABLE is modified
     while iterating.

     For example the following returns a new alist comprising all the
     entries from `mytable', in no particular order.

          (hash-map->list cons mytable)

 -- Scheme Procedure: hash-for-each-handle proc table
 -- C Function: scm_hash_for_each_handle (proc, table)
     Apply PROC to the entries in the given hash TABLE.  Each call is
     `(PROC HANDLE)', where HANDLE is a `(KEY . VALUE)' pair. Return an
     unspecified value.

     `hash-for-each-handle' differs from `hash-for-each' only in the
     argument list of PROC.

 -- Scheme Procedure: hash-fold proc init table
 -- C Function: scm_hash_fold (proc, init, table)
     Accumulate a result by applying PROC to the elements of the given
     hash TABLE.  Each call is `(PROC KEY VALUE PRIOR-RESULT)', where
     KEY and VALUE are from the TABLE and PRIOR-RESULT is the return
     from the previous PROC call.  For the first call, PRIOR-RESULT is
     the given INIT value.

     Calls are made over the table entries in an unspecified order.
     Results will be unpredictable if TABLE is modified while
     `hash-fold' is running.

     For example, the following returns a count of how many keys in
     `mytable' are strings.

          (hash-fold (lambda (key value prior)
                       (if (string? key) (1+ prior) prior))
                     0 mytable)


File: guile.info,  Node: Smobs,  Next: Procedures and Macros,  Prev: Compound Data Types,  Up: API Reference

5.7 Smobs
=========

This chapter contains reference information related to defining and
working with smobs.  See *note Defining New Types (Smobs):: for a
tutorial-like introduction to smobs.

 -- Function: scm_t_bits scm_make_smob_type (const char *name, size_t
          size)
     This function adds a new smob type, named NAME, with instance size
     SIZE, to the system.  The return value is a tag that is used in
     creating instances of the type.

     If SIZE is 0, the default _free_ function will do nothing.

     If SIZE is not 0, the default _free_ function will deallocate the
     memory block pointed to by `SCM_SMOB_DATA' with `scm_gc_free'.
     The WHAT parameter in the call to `scm_gc_free' will be NAME.

     Default values are provided for the _mark_, _free_, _print_, and
     _equalp_ functions, as described in *note Defining New Types
     (Smobs)::.  If you want to customize any of these functions, the
     call to `scm_make_smob_type' should be immediately followed by
     calls to one or several of `scm_set_smob_mark',
     `scm_set_smob_free', `scm_set_smob_print', and/or
     `scm_set_smob_equalp'.

 -- C Function: void scm_set_smob_mark (scm_t_bits tc, SCM (*mark) (SCM
          obj))
     This function sets the smob marking procedure for the smob type
     specified by the tag TC. TC is the tag returned by
     `scm_make_smob_type'.

     The MARK procedure must cause `scm_gc_mark' to be called for every
     `SCM' value that is directly referenced by the smob instance OBJ.
     One of these `SCM' values can be returned from the procedure and
     Guile will call `scm_gc_mark' for it.  This can be used to avoid
     deep recursions for smob instances that form a list.

     It must not call any libguile function or macro except
     `scm_gc_mark', `SCM_SMOB_FLAGS', `SCM_SMOB_DATA',
     `SCM_SMOB_DATA_2', and `SCM_SMOB_DATA_3'.

 -- C Function: void scm_set_smob_free (scm_t_bits tc, size_t (*free)
          (SCM obj))
     This function sets the smob freeing procedure for the smob type
     specified by the tag TC. TC is the tag returned by
     `scm_make_smob_type'.

     The FREE procedure must deallocate all resources that are directly
     associated with the smob instance OBJ.  It must assume that all
     `SCM' values that it references have already been freed and are
     thus invalid.

     It must also not call any libguile function or macro except
     `scm_gc_free', `SCM_SMOB_FLAGS', `SCM_SMOB_DATA',
     `SCM_SMOB_DATA_2', and `SCM_SMOB_DATA_3'.

     The FREE procedure must return 0.

 -- C Function: void scm_set_smob_print (scm_t_bits tc, int (*print)
          (SCM obj, SCM port, scm_print_state* pstate))
     This function sets the smob printing procedure for the smob type
     specified by the tag TC. TC is the tag returned by
     `scm_make_smob_type'.

     The PRINT procedure should output a textual representation of the
     smob instance OBJ to PORT, using information in PSTATE.

     The textual representation should be of the form `#<name ...>'.
     This ensures that `read' will not interpret it as some other
     Scheme value.

     It is often best to ignore PSTATE and just print to PORT with
     `scm_display', `scm_write', `scm_simple_format', and `scm_puts'.

 -- C Function: void scm_set_smob_equalp (scm_t_bits tc, SCM (*equalp)
          (SCM obj1, SCM obj1))
     This function sets the smob equality-testing predicate for the smob
     type specified by the tag TC. TC is the tag returned by
     `scm_make_smob_type'.

     The EQUALP procedure should return `SCM_BOOL_T' when OBJ1 is
     `equal?' to OBJ2.  Else it should return SCM_BOOL_F.  Both OBJ1
     and OBJ2 are instances of the smob type TC.

 -- C Function: void scm_assert_smob_type (scm_t_bits tag, SCM val)
     When VAL is a smob of the type indicated by TAG, do nothing.
     Else, signal an error.

 -- C Macro: int SCM_SMOB_PREDICATE (scm_t_bits tag, SCM exp)
     Return true iff EXP is a smob instance of the type indicated by
     TAG.  The expression EXP can be evaluated more than once, so it
     shouldn't contain any side effects.

 -- C Macro: void SCM_NEWSMOB (SCM value, scm_t_bits tag, void *data)
 -- C Macro: void SCM_NEWSMOB2 (SCM value, scm_t_bits tag, void *data,
          void *data2)
 -- C Macro: void SCM_NEWSMOB3 (SCM value, scm_t_bits tag, void *data,
          void *data2, void *data3)
     Make VALUE contain a smob instance of the type with tag TAG and
     smob data DATA, DATA2, and DATA3, as appropriate.

     The TAG is what has been returned by `scm_make_smob_type'.  The
     initial values DATA, DATA2, and DATA3 are of type `scm_t_bits';
     when you want to use them for `SCM' values, these values need to
     be converted to a `scm_t_bits' first by using `SCM_UNPACK'.

     The flags of the smob instance start out as zero.

   Since it is often the case (e.g., in smob constructors) that you will
create a smob instance and return it, there is also a slightly
specialized macro for this situation:

 -- C Macro:  SCM_RETURN_NEWSMOB (scm_t_bits tag, void *data)
 -- C Macro:  SCM_RETURN_NEWSMOB2 (scm_t_bits tag, void *data1, void
          *data2)
 -- C Macro:  SCM_RETURN_NEWSMOB3 (scm_t_bits tag, void *data1, void
          *data2, void *data3)
     This macro expands to a block of code that creates a smob instance
     of the type with tag TAG and smob data DATA, DATA2, and DATA3, as
     with `SCM_NEWSMOB', etc., and causes the surrounding function to
     return that `SCM' value.  It should be the last piece of code in a
     block.

 -- C Macro: scm_t_bits SCM_SMOB_FLAGS (SCM obj)
     Return the 16 extra bits of the smob OBJ.  No meaning is
     predefined for these bits, you can use them freely.

 -- C Macro: scm_t_bits SCM_SET_SMOB_FLAGS (SCM obj, scm_t_bits flags)
     Set the 16 extra bits of the smob OBJ to FLAGS.  No meaning is
     predefined for these bits, you can use them freely.

 -- C Macro: scm_t_bits SCM_SMOB_DATA (SCM obj)
 -- C Macro: scm_t_bits SCM_SMOB_DATA_2 (SCM obj)
 -- C Macro: scm_t_bits SCM_SMOB_DATA_3 (SCM obj)
     Return the first (second, third) immediate word of the smob OBJ as
     a `scm_t_bits' value.  When the word contains a `SCM' value, use
     `SCM_SMOB_OBJECT' (etc.) instead.

 -- C Macro: void SCM_SET_SMOB_DATA (SCM obj, scm_t_bits val)
 -- C Macro: void SCM_SET_SMOB_DATA_2 (SCM obj, scm_t_bits val)
 -- C Macro: void SCM_SET_SMOB_DATA_3 (SCM obj, scm_t_bits val)
     Set the first (second, third) immediate word of the smob OBJ to
     VAL.  When the word should be set to a `SCM' value, use
     `SCM_SMOB_SET_OBJECT' (etc.) instead.

 -- C Macro: SCM SCM_SMOB_OBJECT (SCM obj)
 -- C Macro: SCM SCM_SMOB_OBJECT_2 (SCM obj)
 -- C Macro: SCM SCM_SMOB_OBJECT_3 (SCM obj)
     Return the first (second, third) immediate word of the smob OBJ as
     a `SCM' value.  When the word contains a `scm_t_bits' value, use
     `SCM_SMOB_DATA' (etc.) instead.

 -- C Macro: void SCM_SET_SMOB_OBJECT (SCM obj, SCM val)
 -- C Macro: void SCM_SET_SMOB_OBJECT_2 (SCM obj, SCM val)
 -- C Macro: void SCM_SET_SMOB_OBJECT_3 (SCM obj, SCM val)
     Set the first (second, third) immediate word of the smob OBJ to
     VAL.  When the word should be set to a `scm_t_bits' value, use
     `SCM_SMOB_SET_DATA' (etc.) instead.

 -- C Macro: SCM * SCM_SMOB_OBJECT_LOC (SCM obj)
 -- C Macro: SCM * SCM_SMOB_OBJECT_2_LOC (SCM obj)
 -- C Macro: SCM * SCM_SMOB_OBJECT_3_LOC (SCM obj)
     Return a pointer to the first (second, third) immediate word of the
     smob OBJ.  Note that this is a pointer to `SCM'.  If you need to
     work with `scm_t_bits' values, use `SCM_PACK' and `SCM_UNPACK', as
     appropriate.

 -- Function: SCM scm_markcdr (SCM X)
     Mark the references in the smob X, assuming that X's first data
     word contains an ordinary Scheme object, and X refers to no other
     objects.  This function simply returns X's first data word.


File: guile.info,  Node: Procedures and Macros,  Next: Utility Functions,  Prev: Smobs,  Up: API Reference

5.8 Procedures and Macros
=========================

* Menu:

* Lambda::                      Basic procedure creation using lambda.
* Primitive Procedures::        Procedures defined in C.
* Optional Arguments::          Handling keyword, optional and rest arguments.
* Procedure Properties::        Procedure properties and meta-information.
* Procedures with Setters::     Procedures with setters.
* Macros::                      Lisp style macro definitions.
* Syntax Rules::                Support for R5RS `syntax-rules'.
* Syntax Case::                 Support for the `syntax-case' system.
* Internal Macros::             Guile's internal representation.


File: guile.info,  Node: Lambda,  Next: Primitive Procedures,  Up: Procedures and Macros

5.8.1 Lambda: Basic Procedure Creation
--------------------------------------

A `lambda' expression evaluates to a procedure.  The environment which
is in effect when a `lambda' expression is evaluated is enclosed in the
newly created procedure, this is referred to as a "closure" (*note
About Closure::).

   When a procedure created by `lambda' is called with some actual
arguments, the environment enclosed in the procedure is extended by
binding the variables named in the formal argument list to new locations
and storing the actual arguments into these locations.  Then the body of
the `lambda' expression is evaluation sequentially.  The result of the
last expression in the procedure body is then the result of the
procedure invocation.

   The following examples will show how procedures can be created using
`lambda', and what you can do with these procedures.

     (lambda (x) (+ x x))       => a procedure
     ((lambda (x) (+ x x)) 4)   => 8

   The fact that the environment in effect when creating a procedure is
enclosed in the procedure is shown with this example:

     (define add4
       (let ((x 4))
         (lambda (y) (+ x y))))
     (add4 6)                   => 10

 -- syntax: lambda formals body
     FORMALS should be a formal argument list as described in the
     following table.

    `(VARIABLE1 ...)'
          The procedure takes a fixed number of arguments; when the
          procedure is called, the arguments will be stored into the
          newly created location for the formal variables.

    `VARIABLE'
          The procedure takes any number of arguments; when the
          procedure is called, the sequence of actual arguments will
          converted into a list and stored into the newly created
          location for the formal variable.

    `(VARIABLE1 ... VARIABLEN . VARIABLEN+1)'
          If a space-delimited period precedes the last variable, then
          the procedure takes N or more variables where N is the number
          of formal arguments before the period.  There must be at
          least one argument before the period.  The first N actual
          arguments will be stored into the newly allocated locations
          for the first N formal arguments and the sequence of the
          remaining actual arguments is converted into a list and the
          stored into the location for the last formal argument.  If
          there are exactly N actual arguments, the empty list is
          stored into the location of the last formal argument.

     The list in VARIABLE or VARIABLEN+1 is always newly created and
     the procedure can modify it if desired.  This is the case even
     when the procedure is invoked via `apply', the required part of
     the list argument there will be copied (*note Procedures for On
     the Fly Evaluation: Fly Evaluation.).

     BODY is a sequence of Scheme expressions which are evaluated in
     order when the procedure is invoked.


File: guile.info,  Node: Primitive Procedures,  Next: Optional Arguments,  Prev: Lambda,  Up: Procedures and Macros

5.8.2 Primitive Procedures
--------------------------

Procedures written in C can be registered for use from Scheme, provided
they take only arguments of type `SCM' and return `SCM' values.
`scm_c_define_gsubr' is likely to be the most useful mechanism,
combining the process of registration (`scm_c_make_gsubr') and
definition (`scm_define').

 -- Function: SCM scm_c_make_gsubr (const char *name, int req, int opt,
          int rst, fcn)
     Register a C procedure FCN as a "subr" -- a primitive subroutine
     that can be called from Scheme.  It will be associated with the
     given NAME but no environment binding will be created.  The
     arguments REQ, OPT and RST specify the number of required,
     optional and "rest" arguments respectively.  The total number of
     these arguments should match the actual number of arguments to
     FCN.  The number of rest arguments should be 0 or 1.
     `scm_c_make_gsubr' returns a value of type `SCM' which is a
     "handle" for the procedure.

 -- Function: SCM scm_c_define_gsubr (const char *name, int req, int
          opt, int rst, fcn)
     Register a C procedure FCN, as for `scm_c_make_gsubr' above, and
     additionally create a top-level Scheme binding for the procedure
     in the "current environment" using `scm_define'.
     `scm_c_define_gsubr' returns a handle for the procedure in the
     same way as `scm_c_make_gsubr', which is usually not further
     required.

   `scm_c_make_gsubr' and `scm_c_define_gsubr' automatically use
`scm_c_make_subr' and also `scm_makcclo' if necessary.  It is advisable
to use the gsubr variants since they provide a slightly higher-level
abstraction of the Guile implementation.


File: guile.info,  Node: Optional Arguments,  Next: Procedure Properties,  Prev: Primitive Procedures,  Up: Procedures and Macros

5.8.3 Optional Arguments
------------------------

Scheme procedures, as defined in R5RS, can either handle a fixed number
of actual arguments, or a fixed number of actual arguments followed by
arbitrarily many additional arguments.  Writing procedures of variable
arity can be useful, but unfortunately, the syntactic means for handling
argument lists of varying length is a bit inconvenient.  It is possible
to give names to the fixed number of argument, but the remaining
(optional) arguments can be only referenced as a list of values (*note
Lambda::).

   Guile comes with the module `(ice-9 optargs)', which makes using
optional arguments much more convenient.  In addition, this module
provides syntax for handling keywords in argument lists (*note
Keywords::).

   Before using any of the procedures or macros defined in this section,
you have to load the module `(ice-9 optargs)' with the statement:

     (use-modules (ice-9 optargs))

* Menu:

* let-optional Reference::      Locally binding optional arguments.
* let-keywords Reference::      Locally binding keywords arguments.
* lambda* Reference::           Creating advanced argument handling procedures.
* define* Reference::           Defining procedures and macros.


File: guile.info,  Node: let-optional Reference,  Next: let-keywords Reference,  Up: Optional Arguments

5.8.3.1 let-optional Reference
..............................

The syntax `let-optional' and `let-optional*' are for destructuring
rest argument lists and giving names to the various list elements.
`let-optional' binds all variables simultaneously, while
`let-optional*' binds them sequentially, consistent with `let' and
`let*' (*note Local Bindings::).

 -- library syntax: let-optional rest-arg (binding ...) expr ...
 -- library syntax: let-optional* rest-arg (binding ...) expr ...
     These two macros give you an optional argument interface that is
     very "Schemey" and introduces no fancy syntax. They are compatible
     with the scsh macros of the same name, but are slightly extended.
     Each of BINDING may be of one of the forms VAR or `(VAR
     DEFAULT-VALUE)'. REST-ARG should be the rest-argument of the
     procedures these are used from.  The items in REST-ARG are
     sequentially bound to the variable names are given. When REST-ARG
     runs out, the remaining vars are bound either to the default
     values or `#f' if no default value was specified. REST-ARG remains
     bound to whatever may have been left of REST-ARG.

     After binding the variables, the expressions EXPR ... are
     evaluated in order.


File: guile.info,  Node: let-keywords Reference,  Next: lambda* Reference,  Prev: let-optional Reference,  Up: Optional Arguments

5.8.3.2 let-keywords Reference
..............................

`let-keywords' and `let-keywords*' extract values from keyword style
argument lists, binding local variables to those values or to defaults.

 -- library syntax: let-keywords args allow-other-keys? (binding ...)
          body ...
 -- library syntax: let-keywords* args allow-other-keys? (binding ...)
          body ...
     ARGS is evaluated and should give a list of the form `(#:keyword1
     value1 #:keyword2 value2 ...)'.  The BINDINGs are variables and
     default expressions, with the variables to be set (by name) from
     the keyword values.  The BODY forms are then evaluated and the
     last is the result.  An example will make the syntax clearest,

          (define args '(#:xyzzy "hello" #:foo "world"))

          (let-keywords args #t
                ((foo  "default for foo")
                 (bar  (string-append "default" "for" "bar")))
            (display foo)
            (display ", ")
            (display bar))
          -| world, defaultforbar

     The binding for `foo' comes from the `#:foo' keyword in `args'.
     But the binding for `bar' is the default in the `let-keywords',
     since there's no `#:bar' in the args.

     ALLOW-OTHER-KEYS? is evaluated and controls whether unknown
     keywords are allowed in the ARGS list.  When true other keys are
     ignored (such as `#:xyzzy' in the example), when `#f' an error is
     thrown for anything unknown.

     `let-keywords' is like `let' (*note Local Bindings::) in that all
     bindings are made at once, the defaults expressions are evaluated
     (if needed) outside the scope of the `let-keywords'.

     `let-keywords*' is like `let*', each binding is made successively,
     and the default expressions see the bindings previously made.
     This is the style used by `lambda*' keywords (*note lambda*
     Reference::).  For example,

          (define args '(#:foo 3))

          (let-keywords* args #f
                ((foo  99)
                 (bar  (+ foo 6)))
            (display bar))
          -| 9

     The expression for each default is only evaluated if it's needed,
     ie. if the keyword doesn't appear in ARGS.  So one way to make a
     keyword mandatory is to throw an error of some sort as the default.

          (define args '(#:start 7 #:finish 13))

          (let-keywords* args #t
                ((start 0)
                 (stop  (error "missing #:stop argument")))
            ...)
          => ERROR: missing #:stop argument

